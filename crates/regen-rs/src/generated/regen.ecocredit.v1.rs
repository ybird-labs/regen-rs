// This file is @generated by prost-build.
/// CreditType defines the measurement unit/precision of a certain credit type
/// (e.g. carbon, biodiversity...)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreditType {
    /// abbreviation is a 1-3 character uppercase abbreviation of the CreditType
    /// name, used in batch denominations within the CreditType. It must be unique.
    #[prost(string, tag = "1")]
    pub abbreviation: ::prost::alloc::string::String,
    /// name is the name of the credit type (e.g. carbon, biodiversity).
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// unit is the measurement unit of the credit type (e.g. kg, ton).
    #[prost(string, tag = "3")]
    pub unit: ::prost::alloc::string::String,
    /// precision is the decimal precision of the credit type.
    #[prost(uint32, tag = "4")]
    pub precision: u32,
}
/// Class represents the high-level on-chain information for a credit class.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Class {
    /// key is the table row identifier of the credit class used internally for
    /// efficient lookups. This identifier is auto-incrementing.
    #[prost(uint64, tag = "1")]
    pub key: u64,
    /// id is the unique identifier of the credit class auto-generated from the
    /// credit type abbreviation and the credit class sequence number.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// admin is the admin of the credit class.
    #[prost(bytes = "vec", tag = "3")]
    pub admin: ::prost::alloc::vec::Vec<u8>,
    /// metadata is any arbitrary metadata to attached to the credit class.
    #[prost(string, tag = "4")]
    pub metadata: ::prost::alloc::string::String,
    /// credit_type_abbrev is the abbreviation of the credit type.
    #[prost(string, tag = "5")]
    pub credit_type_abbrev: ::prost::alloc::string::String,
}
/// ClassIssuers is a JOIN table for Class Info that stores the credit class
/// issuers
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassIssuer {
    /// class_key is the table row identifier of the credit class used internally
    /// for efficient lookups. This links a class issuer to a credit class.
    #[prost(uint64, tag = "1")]
    pub class_key: u64,
    /// issuer is the approved issuer of the credit class.
    #[prost(bytes = "vec", tag = "2")]
    pub issuer: ::prost::alloc::vec::Vec<u8>,
}
/// Project represents the high-level on-chain information for a project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    /// key is the table row identifier of the project used internally for
    /// efficient lookups. This identifier is auto-incrementing.
    #[prost(uint64, tag = "1")]
    pub key: u64,
    /// id is the unique identifier of the project either auto-generated from the
    /// credit class id and project sequence number or provided upon creation.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// admin is the admin of the project.
    #[prost(bytes = "vec", tag = "3")]
    pub admin: ::prost::alloc::vec::Vec<u8>,
    /// class_key is the table row identifier of the credit class used internally
    /// for efficient lookups. This links a project to a credit class.
    #[prost(uint64, tag = "4")]
    pub class_key: u64,
    /// jurisdiction is the jurisdiction of the project.
    /// Full documentation can be found in MsgCreateProject.jurisdiction.
    #[prost(string, tag = "5")]
    pub jurisdiction: ::prost::alloc::string::String,
    /// metadata is any arbitrary metadata attached to the project.
    #[prost(string, tag = "6")]
    pub metadata: ::prost::alloc::string::String,
    /// reference_id is any arbitrary string used to reference the project.
    #[prost(string, tag = "7")]
    pub reference_id: ::prost::alloc::string::String,
}
/// Batch represents the high-level on-chain information for a credit batch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Batch {
    /// key is the table row identifier of the credit batch used internally for
    /// efficient lookups. This identifier is auto-incrementing.
    #[prost(uint64, tag = "1")]
    pub key: u64,
    /// issuer is the address that created the batch and which is
    /// authorized to mint more credits if open=true.
    #[prost(bytes = "vec", tag = "2")]
    pub issuer: ::prost::alloc::vec::Vec<u8>,
    /// project_key is the table row identifier of the credit class used internally
    /// for efficient lookups. This links a credit batch to a project.
    #[prost(uint64, tag = "3")]
    pub project_key: u64,
    /// denom is the unique identifier of the credit batch formed from the
    /// credit class ID (or just project ID for old project IDs which included the credit class),
    /// project id, the batch sequence number, and the start and
    /// end date of the credit batch.
    #[prost(string, tag = "4")]
    pub denom: ::prost::alloc::string::String,
    /// metadata is any arbitrary metadata attached to the credit batch.
    #[prost(string, tag = "5")]
    pub metadata: ::prost::alloc::string::String,
    /// start_date is the beginning of the period during which this credit batch
    /// was quantified and verified.
    #[prost(message, optional, tag = "6")]
    pub start_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// end_date is the end of the period during which this credit batch was
    /// quantified and verified.
    #[prost(message, optional, tag = "7")]
    pub end_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// issuance_date is the timestamp when the credit batch was issued.
    #[prost(message, optional, tag = "8")]
    pub issuance_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// open tells if it's possible to mint new credits in the future.
    /// Once `open` is set to false, it can't be toggled any more.
    #[prost(bool, tag = "9")]
    pub open: bool,
    /// class_key is the table row identifier of the credit class used internally
    /// for efficient lookups. This links a batch to a credit class.
    #[prost(uint64, tag = "10")]
    pub class_key: u64,
}
/// ClassSequence stores and increments the sequence number for credit classes
/// within a credit type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassSequence {
    /// credit_type_abbrev is the credit type abbreviation. This links a class
    /// sequence to a credit type.
    #[prost(string, tag = "1")]
    pub credit_type_abbrev: ::prost::alloc::string::String,
    /// next_sequence is the next sequence number for a credit class within the
    /// credit type. The sequence number is used to generate a class id.
    #[prost(uint64, tag = "2")]
    pub next_sequence: u64,
}
/// ProjectSequence stores and increments the sequence number for projects within
/// a credit class.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProjectSequence {
    /// class_key is the table row identifier of the credit class used internally
    /// for efficient lookups. This links a project sequence to a credit class.
    #[prost(uint64, tag = "1")]
    pub class_key: u64,
    /// next_sequence is the next sequence number for a project within the credit
    /// class. The sequence number is used to generate a project id.
    #[prost(uint64, tag = "2")]
    pub next_sequence: u64,
}
/// BatchSequence stores and increments the sequence number for credit batches
/// within a project.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchSequence {
    /// project_key is the table row identifier of the project used internally for
    /// efficient lookups. This links a batch sequence to a project.
    #[prost(uint64, tag = "1")]
    pub project_key: u64,
    /// next_sequence is the next sequence number for a credit batch within the
    /// project. The sequence number is used to generate a batch denom.
    #[prost(uint64, tag = "2")]
    pub next_sequence: u64,
}
/// BatchBalance stores each accounts credit balance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchBalance {
    /// batch_key is the table row identifier of the credit batch used internally
    /// for efficient lookups. This links a batch balance to a credit batch.
    #[prost(uint64, tag = "1")]
    pub batch_key: u64,
    /// address is the address of the account that owns the credits.
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// tradable_amount is the total number of tradable credits owned by address.
    #[prost(string, tag = "3")]
    pub tradable_amount: ::prost::alloc::string::String,
    /// retired_amount is the total number of retired credits owned by address.
    #[prost(string, tag = "4")]
    pub retired_amount: ::prost::alloc::string::String,
    /// escrowed_amount is the total number of escrowed credits owned by address
    /// and held in escrow by the marketplace. Credits are held in escrow when a
    /// sell order is created and taken out of escrow when the sell order is either
    /// cancelled, updated with a reduced quantity, or processed.
    #[prost(string, tag = "5")]
    pub escrowed_amount: ::prost::alloc::string::String,
}
/// BatchSupply stores the supply of credits for a credit batch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchSupply {
    /// batch_key is the table row identifier of the credit batch used internally
    /// for efficient lookups. This links a batch supply to a credit batch.
    #[prost(uint64, tag = "1")]
    pub batch_key: u64,
    /// tradable_amount is the total number of tradable credits in the credit
    /// batch. Tradable credits may be retired in which case they will be removed
    /// from tradable_amount and tracked in retired_amount. Tradable credits may
    /// also be cancelled in which case they will be removed from tradable_amount
    /// and tracked in cancelled_amount. The sum of the tradable, retired, and
    /// cancelled amounts will always equal the original credit issuance amount.
    #[prost(string, tag = "2")]
    pub tradable_amount: ::prost::alloc::string::String,
    /// retired_amount is the total amount of credits that have been retired in the
    /// credit batch. The sum of the tradable, retired, and cancelled amounts will
    /// always equal the original credit issuance amount.
    #[prost(string, tag = "3")]
    pub retired_amount: ::prost::alloc::string::String,
    /// cancelled_amount is the number of credits in the batch that have been
    /// cancelled, effectively undoing the issuance. The sum of the tradable,
    /// retired, and cancelled amounts will always equal the original credit
    /// issuance amount.
    #[prost(string, tag = "4")]
    pub cancelled_amount: ::prost::alloc::string::String,
}
/// OriginTxIndex indexes the transaction ID and source from the OriginTx
/// included in Msg/CreateBatch and Msg/MintBatchCredits to prevent double
/// minting errors. The index is scoped to a credit class (it includes the
/// class_key) to prevent malicious credit class issuers from blocking any
/// bridge operations taking place within another credit class.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OriginTxIndex {
    /// class_key is the table row identifier of the credit class within which the
    /// credits were issued or minted. The class_key is included within the index
    /// to prevent malicious credit class issuers from blocking bridge operations
    /// taking place within another credit class.
    #[prost(uint64, tag = "1")]
    pub class_key: u64,
    /// id is the transaction ID of an originating transaction or operation
    /// based on a type (i.e. transaction ID, serial number).
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// source is the source chain or registry of the transaction originating
    /// the mint process (e.g. polygon, ethereum, verra).
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
}
/// BatchContract stores the contract address from which credits were bridged
/// when credits are bridged from a contract-based chain, therefore ensuring
/// that each credit batch corresponds to a single contract and credits that
/// have been bridged will always be bridged back to the original contract.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchContract {
    /// batch_key is the table row identifier of the credit batch used internally
    /// for efficient lookups. This links an external contract to a credit batch.
    #[prost(uint64, tag = "1")]
    pub batch_key: u64,
    /// class_key is the table row identifier of the credit class within which the
    /// credit batch exists. A contract is unique within the scope of a credit
    /// class to prevent malicious credit class issuers from blocking bridge
    /// operations taking place within another credit class.
    #[prost(uint64, tag = "2")]
    pub class_key: u64,
    /// contract is the address of the contract on the source chain that was
    /// executed when creating the transaction. This address will be used when
    /// sending credits back to the source chain.
    #[prost(string, tag = "3")]
    pub contract: ::prost::alloc::string::String,
}
/// ClassCreatorAllowlist determines if the credit class creator allowlist is
/// enabled. When set to true, only the addresses in the AllowedClassCreator
/// table may create credit classes. When set to false, any address may create
/// credit classes. This table is controlled via governance.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClassCreatorAllowlist {
    /// enabled is whether or not the allow list is enabled.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// AllowedClassCreator is an allowed credit class creator. This table is
/// controlled via governance.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllowedClassCreator {
    /// address is the address that is allowed to create credit classes
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
/// ClassFee is the credit class creation fee. If not set, a credit class
/// creation fee is not required. This table is controlled via governance.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassFee {
    /// fee is the credit class creation fee. If not set, a credit class creation
    /// fee is not required.
    #[prost(message, optional, tag = "1")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// AllowedBridgeChain is a list of chains that are allowed to be used in
/// bridging operations. NOTE: chain_names MUST be converted to lowercase before
/// writing to and reading from this table in order to keep entries consistent.
/// This table is controlled via governance.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllowedBridgeChain {
    /// chain_name is the name of the chain allowed to bridge ecocredits to.
    #[prost(string, tag = "1")]
    pub chain_name: ::prost::alloc::string::String,
}
/// ProjectEnrollment stores the data a project's enrollment in a credit class.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectEnrollment {
    /// project_key is the table row identifier of the project used internally for
    /// efficient lookups.
    #[prost(uint64, tag = "1")]
    pub project_key: u64,
    /// class_key is the table row identifier of the credit class used internally
    /// for efficient lookups.
    #[prost(uint64, tag = "3")]
    pub class_key: u64,
    /// status is the status of the enrollment.
    #[prost(enumeration = "ProjectEnrollmentStatus", tag = "4")]
    pub status: i32,
    /// application_metadata is any arbitrary metadata set by the project
    /// admin related to its application to the credit class.
    #[prost(string, tag = "5")]
    pub application_metadata: ::prost::alloc::string::String,
    /// enrollment_metadata is any arbitrary metadata set by the credit class
    /// admin evaluating the project's application to the credit class.
    #[prost(string, tag = "6")]
    pub enrollment_metadata: ::prost::alloc::string::String,
}
/// ProjectFee is the project creation fee. If not set, a project creation fee is
/// not required. This table is controlled via governance.
///
/// Since Revision 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectFee {
    /// fee is the project creation fee. If not set, a project creation fee is not
    /// required.
    #[prost(message, optional, tag = "1")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// Application represents the evaluation status that a credit class issuer
/// assigns to a credit class application.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProjectEnrollmentStatus {
    /// PROJECT_ENROLLMENT_STATUS_UNSPECIFIED indicates that a credit class application
    /// has been submitted but not evaluated.
    Unspecified = 0,
    /// PROJECT_ENROLLMENT_STATUS_ACCEPTED indicates that the project has been
    /// accepted into the credit class.
    Accepted = 1,
    /// PROJECT_ENROLLMENT_STATUS_CHANGES_REQUESTED indicates that an application to
    /// a credit class has been reviewed and that changes to the application have
    /// been requested. It can also be used to indicate that a project within a credit
    /// class has had its status reassessed and that changes to the project are
    /// requested in order to continue in the credit class.
    ChangesRequested = 2,
    /// PROJECT_ENROLLMENT_STATUS_REJECTED indicates that the application has been
    /// rejected and that the project will not be accepted into the credit class.
    Rejected = 3,
    /// PROJECT_ENROLLMENT_STATUS_TERMINATED indicates that the project has been
    /// terminated from the credit class. This status is used when a project the
    /// was previously accepted into the credit class but has been removed or
    /// completed.
    Terminated = 4,
}
impl ProjectEnrollmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROJECT_ENROLLMENT_STATUS_UNSPECIFIED",
            Self::Accepted => "PROJECT_ENROLLMENT_STATUS_ACCEPTED",
            Self::ChangesRequested => "PROJECT_ENROLLMENT_STATUS_CHANGES_REQUESTED",
            Self::Rejected => "PROJECT_ENROLLMENT_STATUS_REJECTED",
            Self::Terminated => "PROJECT_ENROLLMENT_STATUS_TERMINATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROJECT_ENROLLMENT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "PROJECT_ENROLLMENT_STATUS_ACCEPTED" => Some(Self::Accepted),
            "PROJECT_ENROLLMENT_STATUS_CHANGES_REQUESTED" => Some(Self::ChangesRequested),
            "PROJECT_ENROLLMENT_STATUS_REJECTED" => Some(Self::Rejected),
            "PROJECT_ENROLLMENT_STATUS_TERMINATED" => Some(Self::Terminated),
            _ => None,
        }
    }
}
/// Params defines the updatable global parameters of the ecocredit module for
/// use with the x/params module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    /// credit_class_fee is a list of credit class creation fees accepted when
    /// creating a credit class. Any fee listed is accepted and charged to the
    /// credit class creator when creating a credit class.
    #[prost(message, repeated, tag = "1")]
    pub credit_class_fee: ::prost::alloc::vec::Vec<
        ::cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
    /// basket_fee is a list of basket creation fees accepted when creating a
    /// basket. Any fee listed is accepted and charged to the basket creator when
    /// creating a basket.
    #[prost(message, repeated, tag = "2")]
    pub basket_fee: ::prost::alloc::vec::Vec<
        ::cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
    /// allowed_class_creators is an allowlist defining the addresses with the
    /// required permissions to create credit classes when allowlist_enabled is set
    /// to true. If allowlist_enabled is set to false, this list has no effect.
    #[prost(string, repeated, tag = "3")]
    pub allowed_class_creators: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// allowlist_enabled determines whether or not the allowlist for creating
    /// credit classes is enabled. When set to true, only the addresses listed in
    /// allowed_class_creators can create credit classes. When set to false, any
    /// address can create credit classes.
    #[prost(bool, tag = "4")]
    pub allowlist_enabled: bool,
    /// allowed_denoms is a list of bank denoms allowed to be used in the ask price
    /// of sell orders.
    ///
    /// Since Revision 2
    #[prost(message, repeated, tag = "5")]
    pub allowed_denoms: ::prost::alloc::vec::Vec<AllowedDenom>,
    /// AllowedBridgeChains is a list of chain names that are allowed to be used in
    /// bridge operations.
    ///
    /// Since Revision 2
    #[prost(string, repeated, tag = "6")]
    pub allowed_bridge_chains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Credits represents a simple structure for credits.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Credits {
    /// batch_denom is the denom of the credit batch.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
    /// amount is the amount of credits.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
/// BatchIssuance represents a simple structure for a credit batch issuance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchIssuance {
    /// recipient is the address of the account receiving the issued credits.
    #[prost(string, tag = "1")]
    pub recipient: ::prost::alloc::string::String,
    /// tradable_amount is the amount of credits that the recipient will receive in
    /// a tradable state. The number of decimal places must be less than or equal
    /// to the credit type precision.
    #[prost(string, tag = "2")]
    pub tradable_amount: ::prost::alloc::string::String,
    /// retired_amount is the amount of credits that the recipient will receive in
    /// a retired state. The number of decimal places must be less than or equal to
    /// the credit type precision.
    #[prost(string, tag = "3")]
    pub retired_amount: ::prost::alloc::string::String,
    /// retirement_jurisdiction is the jurisdiction of the recipient and is only
    /// required if retired_amount is positive. A jurisdiction has the following
    /// format: <country-code>\[-<sub-national-code>[ <postal-code>]\]
    /// The country-code must be 2 alphabetic characters, the sub-national-code
    /// can be 1-3 alphanumeric characters, and the postal-code can be up to 64
    /// alphanumeric characters. Only the country-code is required, while the
    /// sub-national-code and postal-code are optional and can be added for
    /// increased precision.
    #[prost(string, tag = "4")]
    pub retirement_jurisdiction: ::prost::alloc::string::String,
    /// retirement_reason is any arbitrary string that specifies the reason for
    /// retiring credits. The reason will be included in EventRetire and is not
    /// stored in state.
    ///
    /// Since Revision 2
    #[prost(string, tag = "5")]
    pub retirement_reason: ::prost::alloc::string::String,
}
/// OriginTx is the transaction from another chain or registry that triggered
/// the minting of credits.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OriginTx {
    /// id is the transaction ID of an originating transaction or operation based
    /// on a type (i.e. transaction ID, serial number).
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// source is the source chain or registry of the transaction originating the
    /// mint process (e.g. polygon, ethereum, verra).
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// contract is the address of the contract on the source chain that was
    /// executed when creating the transaction. This address will be stored in
    /// state separately from the origin tx and on a per credit batch basis to be
    /// used when sending credits back to the source chain. This field can be left
    /// blank if credits are bridged from a non-contract-based source.
    #[prost(string, tag = "3")]
    pub contract: ::prost::alloc::string::String,
    /// note is a reference note for accounting that will be included in an event
    /// emitted from either Msg/CreateBatch or Msg/MintBatchCredits.
    #[prost(string, tag = "4")]
    pub note: ::prost::alloc::string::String,
}
/// CreditTypeProposal is a gov Content type for adding a credit type.
/// Deprecated (Since Revision 2): This message is no longer used and will be
/// removed in the next version. See MsgAddCreditType.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreditTypeProposal {
    /// title is the title of the proposal.
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// description is the description of the proposal.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// credit_type is the credit type to be added to the network if the proposal
    /// passes.
    #[prost(message, optional, tag = "3")]
    pub credit_type: ::core::option::Option<CreditType>,
}
/// AllowedDenom represents the information for an allowed ask denom.
///
/// Since Revision 2
///
/// Deprecated(Since Revision 2): This type was added to support historical
/// queries for params but will also be removed in the next version.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllowedDenom {
    /// denom is the bank denom to allow (ex. ibc/GLKHDSG423SGS)
    #[prost(string, tag = "1")]
    pub bank_denom: ::prost::alloc::string::String,
    /// display_denom is the denom to display to the user and is informational.
    /// Because the denom is likely an IBC denom, this should be chosen by
    /// governance to represent the consensus trusted name of the denom.
    #[prost(string, tag = "2")]
    pub display_denom: ::prost::alloc::string::String,
    /// exponent is the exponent that relates the denom to the display_denom and is
    /// informational
    #[prost(uint32, tag = "3")]
    pub exponent: u32,
}
/// MsgAddCreditType is the Msg/AddCreditType request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddCreditType {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// credit_type defines a credit type to add to the credit types parameter.
    #[prost(message, optional, tag = "2")]
    pub credit_type: ::core::option::Option<CreditType>,
}
/// MsgAddCreditTypeResponse is the Msg/AddCreditType response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddCreditTypeResponse {}
/// MsgCreateClass is the Msg/CreateClass request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateClass {
    /// admin is the address of the account creating the credit class that will
    /// become the admin of the credit class upon creation. The admin will have
    /// permissions within the credit class to update the credit class including
    /// the list of approved issuers. If Params.allowlist_enabled is set to true,
    /// this address must be included in Params.allowed_class_creators.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// issuers are the addresses of the accounts that will have permissions within
    /// the credit class to create projects and issue credits.
    #[prost(string, repeated, tag = "2")]
    pub issuers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// metadata is any arbitrary string with a maximum length of 256 characters
    /// that includes or references metadata to attach to the credit class.
    #[prost(string, tag = "3")]
    pub metadata: ::prost::alloc::string::String,
    /// credit_type_abbrev is the abbreviation of the credit type under which the
    /// credit class will be created (e.g. "C", "BIO").
    #[prost(string, tag = "4")]
    pub credit_type_abbrev: ::prost::alloc::string::String,
    /// fee is the credit class creation fee. An equal fee is required if the class
    /// creation fee parameter is set. The provided fee can be greater than the
    /// parameter, but only the amount in the parameter will be charged.
    #[prost(message, optional, tag = "5")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgCreateClassResponse is the Msg/CreateClass response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateClassResponse {
    /// class_id is the unique identifier of the credit class.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
}
/// MsgCreateProjectResponse is the Msg/CreateProject request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateProject {
    /// admin is the address of the account creating the project that will become
    /// the admin of the project upon creation. The creator of the project must be
    /// an approved issuer within the credit class under which the project is being
    /// created. The admin will have permissions to update the project including
    /// the ability to reassign the admin role to another account.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the credit class under which the
    /// project will be created.
    #[prost(string, tag = "2")]
    pub class_id: ::prost::alloc::string::String,
    /// metadata is any arbitrary string with a maximum length of 256 characters
    /// that includes or references metadata to attach to the project.
    #[prost(string, tag = "3")]
    pub metadata: ::prost::alloc::string::String,
    /// jurisdiction is the jurisdiction of the project. A jurisdiction has with
    /// the format: <country-code>\[-<sub-national-code>[ <postal-code>]\]
    /// The country-code must be 2 alphabetic characters, the sub-national-code
    /// can be 1-3 alphanumeric characters, and the postal-code can be up to 64
    /// alphanumeric characters. Only the country-code is required, while the
    /// sub-national-code and postal-code are optional and can be added for
    /// increased precision.
    #[prost(string, tag = "4")]
    pub jurisdiction: ::prost::alloc::string::String,
    /// reference_id is any arbitrary string used to reference the project with a
    /// maximum length of 32 characters.
    #[prost(string, tag = "5")]
    pub reference_id: ::prost::alloc::string::String,
    /// fee is the project creation fee. An equal fee is required if the project
    /// creation fee parameter is set. The provided fee can be greater than the
    /// parameter, but only the amount in the parameter will be charged.
    ///
    /// Since Revision 3
    #[prost(message, optional, tag = "6")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgCreateProjectResponse is the Msg/CreateProject response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateProjectResponse {
    /// project_id is the unique identifier of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
}
/// MsgCreateUnregisteredProject is the Msg/CreateUnregisteredProject request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateUnregisteredProject {
    /// admin is the address of the account creating the project that will become
    /// the admin of the project upon creation.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// metadata is any arbitrary string with a maximum length of 256 characters
    /// that includes or references metadata to attach to the project.
    #[prost(string, tag = "2")]
    pub metadata: ::prost::alloc::string::String,
    /// jurisdiction is the jurisdiction of the project. A jurisdiction has with
    /// the format: <country-code>\[-<sub-national-code>[ <postal-code>]\]
    /// The country-code must be 2 alphabetic characters, the sub-national-code
    /// can be 1-3 alphanumeric characters, and the postal-code can be up to 64
    /// alphanumeric characters. Only the country-code is required, while the
    /// sub-national-code and postal-code are optional and can be added for
    /// increased precision.
    #[prost(string, tag = "3")]
    pub jurisdiction: ::prost::alloc::string::String,
    /// reference_id is any arbitrary string used to reference the project with a
    /// maximum length of 32 characters.
    #[prost(string, tag = "4")]
    pub reference_id: ::prost::alloc::string::String,
    /// fee is the project creation fee. An equal fee is required if the project
    /// creation fee parameter is set. The provided fee can be greater than the
    /// parameter, but only the amount in the parameter will be charged.
    ///
    /// Since Revision 3
    #[prost(message, optional, tag = "5")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgCreateUnregisteredProjectResponse is the Msg/CreateUnregisteredProject response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateUnregisteredProjectResponse {
    /// project_id is the unique identifier of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
}
/// MsgCreateOrUpdateApplication is the Msg/CreateOrUpdateApplication request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateOrUpdateApplication {
    /// project_admin is the address of the account that is the admin of the
    /// project which is applying to the credit class.
    #[prost(string, tag = "1")]
    pub project_admin: ::prost::alloc::string::String,
    /// project_id is the identifier of the project which is applying to
    /// the credit class.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// class_id is the identifier of the credit class which the project is
    /// applying to.
    #[prost(string, tag = "3")]
    pub class_id: ::prost::alloc::string::String,
    /// metadata is any optional arbitrary string with a maximum length of 256 characters
    /// that includes or references any metadata relevant to the application.
    /// This could be used as a digital reference to the actual contents of the application.
    #[prost(string, tag = "4")]
    pub metadata: ::prost::alloc::string::String,
    /// withdraw is a boolean that indicates whether the application is being
    /// withdrawn rather than updated.
    #[prost(bool, tag = "5")]
    pub withdraw: bool,
}
/// MsgCreateOrUpdateApplicationResponse is the Msg/CreateOrUpdateApplication response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCreateOrUpdateApplicationResponse {}
/// MsgUpdateProjectEnrollment is the Msg/UpdateProjectEnrollment request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectEnrollment {
    /// issuer is the address of the account that is the issuer of the credit class
    /// which is updating the project enrollment status.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// project_id is the identifier of the project.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// class_id is the identifier of the credit class.
    #[prost(string, tag = "3")]
    pub class_id: ::prost::alloc::string::String,
    /// new_status is the new status of the project enrollment.
    #[prost(enumeration = "ProjectEnrollmentStatus", tag = "4")]
    pub new_status: i32,
    /// metadata is any optiopnal arbitrary string with a maximum length of 256 characters
    /// that includes or references the reason for the approving, requesting changes
    /// to, or rejecting the application, or terminating the project.
    #[prost(string, tag = "5")]
    pub metadata: ::prost::alloc::string::String,
}
/// MsgEvaluateProjectEnrollmentResponse is the Msg/EvaluateProjectEnrollment response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectEnrollmentResponse {}
/// MsgCreateBatch is the Msg/CreateBatch request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateBatch {
    /// issuer is the address of the account issuing the credits and must be an
    /// approved issuer within a credit class of the project.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// project_id is the unique identifier of the project under which the credit
    /// batch will be created.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// issuance specifies the amount of tradable and retired credits that will be
    /// issued to each recipient and the jurisdiction in which the credits will be
    /// retired if credits are to be retired upon receipt.
    #[prost(message, repeated, tag = "3")]
    pub issuance: ::prost::alloc::vec::Vec<BatchIssuance>,
    /// metadata is any arbitrary string with a maximum length of 256 characters
    /// that includes or references metadata to attach to the credit batch.
    #[prost(string, tag = "4")]
    pub metadata: ::prost::alloc::string::String,
    /// start_date is the beginning of the period during which this credit batch
    /// was quantified and verified.
    #[prost(message, optional, tag = "5")]
    pub start_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// end_date is the end of the period during which this credit batch was
    /// quantified and verified.
    #[prost(message, optional, tag = "6")]
    pub end_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// open determines whether or not the credits can be dynamically minted to the
    /// credit batch following the creation of the credit batch. This field should
    /// only be set to true when bridging credits from another chain or registry as
    /// a result of a bridge operation and is not intended for native issuance.
    #[prost(bool, tag = "7")]
    pub open: bool,
    /// origin_tx is the transaction from another chain or registry that triggered
    /// the creation of the credit batch. This field can be ignored when natively
    /// issuing credits and should only be set when bridging assets from another
    /// chain or registry as a result of a bridge operation.
    #[prost(message, optional, tag = "8")]
    pub origin_tx: ::core::option::Option<OriginTx>,
    /// class_id is the unique identifier of the credit class under which the
    /// credit batch will be created.
    ///
    /// Since Revision 3
    #[prost(string, tag = "9")]
    pub class_id: ::prost::alloc::string::String,
}
/// MsgCreateBatchResponse is the Msg/CreateBatch response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCreateBatchResponse {
    /// batch_denom is the unique identifier of the credit batch.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// MsgMintBatchCredits is the Msg/MintBatchCredits request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMintBatchCredits {
    /// issuer is the address of the account minting the credits and must be the
    /// same issuer who created the credit batch.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
    /// issuance specifies the amount of tradable and retired credits that will be
    /// issued to each recipient and the jurisdiction in which the credits will be
    /// retired if credits are to be retired upon receipt.
    #[prost(message, repeated, tag = "3")]
    pub issuance: ::prost::alloc::vec::Vec<BatchIssuance>,
    /// origin_tx is the transaction from another chain or registry that triggered
    /// the minting of credits.
    #[prost(message, optional, tag = "4")]
    pub origin_tx: ::core::option::Option<OriginTx>,
}
/// MsgMintBatchCreditsResponse is the Msg/MintBatchCredits response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMintBatchCreditsResponse {}
/// MsgSealBatch is the Msg/MintBatchCredits request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSealBatch {
    /// issuer is the address of the account that created the credit batch and the
    /// only account with permissions to seal the credit batch.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// MsgSealBatchResponse is the Msg/SealBatch response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSealBatchResponse {}
/// MsgSend is the Msg/Send request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSend {
    /// sender is the address of the account sending credits.
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    /// recipient is the address of the account receiving credits.
    #[prost(string, tag = "2")]
    pub recipient: ::prost::alloc::string::String,
    /// credits are the credits being sent to the recipient.
    #[prost(message, repeated, tag = "3")]
    pub credits: ::prost::alloc::vec::Vec<msg_send::SendCredits>,
}
/// Nested message and enum types in `MsgSend`.
pub mod msg_send {
    /// SendCredits specifies the amount of tradable and retired credits of a
    /// credit batch that will be sent to the recipient and the jurisdiction in
    /// which the credits will be retired upon receipt.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendCredits {
        /// batch_denom is the unique identifier of the credit batch.
        #[prost(string, tag = "1")]
        pub batch_denom: ::prost::alloc::string::String,
        /// tradable_amount is the amount of credits in this transfer that can be
        /// traded by the recipient. The number of decimal places must be less than
        /// or equal to the credit type precision.
        #[prost(string, tag = "2")]
        pub tradable_amount: ::prost::alloc::string::String,
        /// retired_amount is the amount of credits in this transfer that are retired
        /// upon receipt. The number of decimal places must be less than or equal to
        /// the credit type precision.
        #[prost(string, tag = "3")]
        pub retired_amount: ::prost::alloc::string::String,
        /// retirement_jurisdiction is the jurisdiction of the recipient and is only
        /// required if retired_amount is positive. A jurisdiction has the format:
        /// <country-code>\[-<sub-national-code>[ <postal-code>]\]
        /// The country-code and sub-national-code must conform to ISO 3166-2 and the
        /// postal-code can be up to 64 alphanumeric characters. Only the
        /// country-code is required, while the sub-national-code and postal-code are
        /// optional and can be added for increased precision.
        #[prost(string, tag = "4")]
        pub retirement_jurisdiction: ::prost::alloc::string::String,
        /// retirement_reason is any arbitrary string that specifies the reason for
        /// retiring credits. This field is only required if retired_amount is
        /// positive.
        ///
        /// Since Revision 2
        #[prost(string, tag = "5")]
        pub retirement_reason: ::prost::alloc::string::String,
    }
}
/// MsgSendResponse is the Msg/Send response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSendResponse {}
/// MsgRetire is the Msg/Retire request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRetire {
    /// owner is the address of the account that owns the credits being retired.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// credits specifies a credit batch and the number of credits being retired.
    #[prost(message, repeated, tag = "2")]
    pub credits: ::prost::alloc::vec::Vec<Credits>,
    /// jurisdiction is the jurisdiction of the credit owner. A jurisdiction has
    /// the format: <country-code>\[-<sub-national-code>[ <postal-code>]\]
    /// The country-code must be 2 alphabetic characters, the sub-national-code
    /// can be 1-3 alphanumeric characters, and the postal-code can be up to 64
    /// alphanumeric characters. Only the country-code is required, while the
    /// sub-national-code and postal-code are optional and can be added for
    /// increased precision.
    #[prost(string, tag = "3")]
    pub jurisdiction: ::prost::alloc::string::String,
    /// reason is any arbitrary string that specifies the reason for retiring
    /// credits.
    ///
    /// Since Revision 2
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
}
/// MsgRetire is the Msg/Retire response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRetireResponse {}
/// MsgCancel is the Msg/Cancel request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgCancel {
    /// owner is the address of the account that owns the credits being cancelled.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// credits specifies a credit batch and the number of credits being cancelled.
    #[prost(message, repeated, tag = "2")]
    pub credits: ::prost::alloc::vec::Vec<Credits>,
    /// reason is any arbitrary string that specifies the reason for cancelling
    /// credits.
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
/// MsgCancelResponse is the Msg/Cancel response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgCancelResponse {}
/// MsgUpdateClassAdmin is the Msg/UpdateClassAdmin request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassAdmin {
    /// admin is the address of the account that is currently the admin of the
    /// credit class.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the credit class.
    #[prost(string, tag = "2")]
    pub class_id: ::prost::alloc::string::String,
    /// new_admin is the address of the account that will become the new admin of
    /// the credit class.
    #[prost(string, tag = "3")]
    pub new_admin: ::prost::alloc::string::String,
}
/// MsgUpdateClassAdminResponse is the MsgUpdateClassAdmin response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassAdminResponse {}
/// MsgUpdateClassIssuers is the Msg/UpdateClassIssuers request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassIssuers {
    /// admin is the address of the account that is the admin of the credit class.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the credit class.
    #[prost(string, tag = "2")]
    pub class_id: ::prost::alloc::string::String,
    /// add_issuers are the addresses of the accounts that will be added to the
    /// list of approved credit class issuers.
    #[prost(string, repeated, tag = "3")]
    pub add_issuers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// remove_issuers are the addresses of the accounts that will be removed from
    /// the list of approved credit class issuers.
    #[prost(string, repeated, tag = "4")]
    pub remove_issuers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MsgUpdateClassIssuersResponse is the MsgUpdateClassIssuers response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassIssuersResponse {}
/// MsgUpdateClassMetadata is the Msg/UpdateClassMetadata request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassMetadata {
    /// admin is the address of the account that is the admin of the credit class.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the credit class.
    #[prost(string, tag = "2")]
    pub class_id: ::prost::alloc::string::String,
    /// new_metadata is new metadata that will replace the existing metadata. It
    /// can be any arbitrary string with a maximum length of 256 characters that
    /// includes or references the metadata to attach to the credit class.
    #[prost(string, tag = "3")]
    pub new_metadata: ::prost::alloc::string::String,
}
/// MsgUpdateClassMetadataResponse is the Msg/UpdateClassMetadata response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassMetadataResponse {}
/// MsgUpdateProjectAdmin is the Msg/UpdateProjectAdmin request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectAdmin {
    /// admin is the address of the account that is the currently the admin of the
    /// project.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// project_id is the unique identifier of the project.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// new_admin is the address of the account that will become the new admin of
    /// the project.
    #[prost(string, tag = "3")]
    pub new_admin: ::prost::alloc::string::String,
}
/// MsgUpdateProjectAdmin is the Msg/UpdateProjectAdmin response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectAdminResponse {}
/// MsgUpdateProjectMetadata is the Msg/UpdateProjectMetadata request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectMetadata {
    /// admin is the address of the account that is the admin of the project.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// project_id is the unique identifier of the project.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// new_metadata is new metadata that will replace the existing metadata. It
    /// can be any arbitrary string with a maximum length of 256 characters that
    /// includes or references the metadata to attach to the project.
    #[prost(string, tag = "3")]
    pub new_metadata: ::prost::alloc::string::String,
}
/// MsgUpdateProjectMetadataResponse is the Msg/UpdateProjectMetadataResponse
/// response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectMetadataResponse {}
/// MsgBridge is the Msg/Bridge request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBridge {
    /// owner is the address of the account that owns the credits being bridged.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// target is the name of the target chain or registry.
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    /// recipient is the address of the account receiving the bridged credits.
    #[prost(string, tag = "3")]
    pub recipient: ::prost::alloc::string::String,
    /// credits specifies a credit batch and the number of credits being bridged.
    #[prost(message, repeated, tag = "4")]
    pub credits: ::prost::alloc::vec::Vec<Credits>,
}
/// MsgUpdateBatchMetadata is the Msg/UpdateBatchMetadata request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateBatchMetadata {
    /// issuer is the address of the account that is the issuer of the batch.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the batch.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
    /// new_metadata is new metadata that will replace the existing metadata. It
    /// can be any arbitrary string with a maximum length of 256 characters that
    /// includes or references the metadata to attach to the batch.
    #[prost(string, tag = "3")]
    pub new_metadata: ::prost::alloc::string::String,
}
/// MsgUpdateBatchMetadataResponse is the Msg/UpdateBatchMetadataResponse
/// response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateBatchMetadataResponse {}
/// MsgBridgeResponse is the Msg/Bridge response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgBridgeResponse {}
/// MsgBridgeReceive is the Msg/BridgeReceive request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBridgeReceive {
    /// issuer is the account address of the service bridging the credits.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the credit class within which the
    /// project and credit batch already exist or will be created.
    #[prost(string, tag = "2")]
    pub class_id: ::prost::alloc::string::String,
    /// project defines the project information for the bridged credits.
    #[prost(message, optional, tag = "3")]
    pub project: ::core::option::Option<msg_bridge_receive::Project>,
    /// batch defines the credit batch information for the bridged credits.
    #[prost(message, optional, tag = "4")]
    pub batch: ::core::option::Option<msg_bridge_receive::Batch>,
    /// origin_tx is a reference to a transaction which caused the transfer from
    /// another chain or registry.
    #[prost(message, optional, tag = "5")]
    pub origin_tx: ::core::option::Option<OriginTx>,
}
/// Nested message and enum types in `MsgBridgeReceive`.
pub mod msg_bridge_receive {
    /// Batch defines the credit batch information for the bridged credits. This
    /// information will be used to create a credit batch or to dynamically mint
    /// credits to an existing credit batch.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Batch {
        /// recipient is the recipient of the bridged credits.
        #[prost(string, tag = "1")]
        pub recipient: ::prost::alloc::string::String,
        /// amount is the amount of credits being bridged.
        #[prost(string, tag = "2")]
        pub amount: ::prost::alloc::string::String,
        /// start_date is the beginning of the period during which this credit batch
        /// was quantified and verified.
        #[prost(message, optional, tag = "3")]
        pub start_date: ::core::option::Option<
            ::tendermint_proto::google::protobuf::Timestamp,
        >,
        /// end_date is the end of the period during which this credit batch was
        /// quantified and verified.
        #[prost(message, optional, tag = "4")]
        pub end_date: ::core::option::Option<
            ::tendermint_proto::google::protobuf::Timestamp,
        >,
        /// metadata is the metadata for the credit batch.
        #[prost(string, tag = "5")]
        pub metadata: ::prost::alloc::string::String,
    }
    /// Project defines the project information for the bridged credits. This
    /// information will be used to find an existing project or to create a new
    /// project if a project with the same reference id does not already exist.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Project {
        /// reference_id is the reference id of the project.
        #[prost(string, tag = "1")]
        pub reference_id: ::prost::alloc::string::String,
        /// jurisdiction is the project jurisdiction.
        #[prost(string, tag = "2")]
        pub jurisdiction: ::prost::alloc::string::String,
        /// metadata is the metadata for the project.
        #[prost(string, tag = "3")]
        pub metadata: ::prost::alloc::string::String,
    }
}
/// MsgBridgeReceiveResponse is the Msg/BridgeReceive response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBridgeReceiveResponse {
    /// batch_denom is the unique identifier of the credit batch either created
    /// or within which the credits were dynamically minted.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
    /// project_id is the unique identifier of the project that was either created
    /// or the existing project within which the credit batch exists.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
}
/// MsgAddClassCreator is the Msg/AddClassCreator request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddClassCreator {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// creator is the address to add to the class creator list.
    #[prost(string, tag = "2")]
    pub creator: ::prost::alloc::string::String,
}
/// MsgAddClassCreatorResponse is the Msg/AddClassCreator response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddClassCreatorResponse {}
/// MsgSetClassCreatorAllowlist is the Msg/SetClassCreatorAllowlist request
/// type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetClassCreatorAllowlist {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// enabled defines the boolean value to set the allowlist on or off.
    #[prost(bool, tag = "2")]
    pub enabled: bool,
}
/// MsgSetClassCreatorAllowlistResponse is the Msg/SetClassCreatorAllowlist
/// response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetClassCreatorAllowlistResponse {}
/// MsgRemoveClassCreator is the Msg/RemoveClassCreator request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemoveClassCreator {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// creator is the address to remove from the class creator list.
    #[prost(string, tag = "2")]
    pub creator: ::prost::alloc::string::String,
}
/// MsgRemoveClassCreatorResponse is the Msg/RemoveClasssCreator response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemoveClassCreatorResponse {}
/// MsgUpdateClassFee is the Msg/UpdateClassFee request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassFee {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// fee is the credit class creation fee. If not set, the credit class creation
    /// fee will be removed and no fee will be required to create a credit class.
    #[prost(message, optional, tag = "2")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgUpdateClassFeeResponse is the Msg/UpdateClassFee response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateClassFeeResponse {}
/// MsgUpdateProjectFee is the Msg/UpdateProjectFee request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectFee {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// fee is the project creation fee. If not set, the project creation fee will
    /// be removed and no fee will be required to create a project.
    #[prost(message, optional, tag = "2")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// MsgUpdateProjectFeeResponse is the Msg/UpdateProjectFee response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateProjectFeeResponse {}
/// MsgAddAllowedBridgeChain is the Msg/AddAllowedBridgeChain request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddAllowedBridgeChain {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// chain_name is the name of the chain to allow bridging of ecocredits to
    /// (i.e. polygon, ethereum, celo).
    #[prost(string, tag = "2")]
    pub chain_name: ::prost::alloc::string::String,
}
/// MsgAddAllowedBridgeChainResponse is the Msg/AddAllowedBridgeChain response
/// type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddAllowedBridgeChainResponse {}
/// MsgRemoveAllowedBridgeChain is the Msg/RemoveAllowedBridgeChain request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemoveAllowedBridgeChain {
    /// authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// chain_name is the name of the chain to remove from the list of allowed
    /// chains to bridge ecocredits to (i.e. polygon, ethereum, celo).
    #[prost(string, tag = "2")]
    pub chain_name: ::prost::alloc::string::String,
}
/// MsgRemoveAllowedBridgeChainResponse is the Msg/RemoveAllowedBridgeChain
/// response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemoveAllowedBridgeChainResponse {}
/// MsgBurnRegen is the Msg/BurnRegen request type.
///
/// Since Revision 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBurnRegen {
    /// burner is the address of the account burning REGEN tokens.
    #[prost(string, tag = "1")]
    pub burner: ::prost::alloc::string::String,
    /// amount is the integer amount of uregen tokens to burn.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// reason is any arbitrary string that specifies the reason for burning
    /// REGEN tokens. It may be at most 256 characters long.
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
/// MsgBurnResponse is the Msg/Burn response type.
///
/// Since Revision 3
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgBurnRegenResponse {}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg is the regen.ecocredit.v1 Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// CreateClass creates a new credit class under the given credit type with an
        /// approved list of issuers and optional metadata. If the class fee parameter
        /// is set, the fee field must be populated with equal value. A greater fee can
        /// be provided, however, the creator will only be charged the amount specified
        /// in the fee parameter. The creator of the credit class becomes the admin of
        /// the credit class upon creation.
        pub async fn create_class(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateClass>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateClassResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/CreateClass",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "CreateClass"));
            self.inner.unary(req, path, codec).await
        }
        /// CreateProject creates a new project under the given credit class with a
        /// jurisdiction, optional metadata, and an optional reference ID. The creator
        /// of the project must be an approved credit class issuer for the given credit
        /// class. The creator becomes the admin of the project upon creation.
        pub async fn create_project(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateProject>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/CreateProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "CreateProject"));
            self.inner.unary(req, path, codec).await
        }
        /// CreateUnregisteredProject creates a new project without registering it
        /// under a credit class. This method is intended to be used by project proponents
        /// who are not yet ready to register their project under a credit class, but who
        /// want to create a project and receive a project ID.
        pub async fn create_unregistered_project(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateUnregisteredProject>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateUnregisteredProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/CreateUnregisteredProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "regen.ecocredit.v1.Msg",
                        "CreateUnregisteredProject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CreateOrUpdateApplicaton creates a new project credit class application, updates
        /// the metadata for an existing one when changes have been requested, or withdraws
        /// the application. When an application is withdrawn, its data will be deleted from
        /// state and the project may apply again to the same credit class in the future.
        ///
        /// Since Revision 3
        pub async fn create_or_update_application(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateOrUpdateApplication>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateOrUpdateApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/CreateOrUpdateApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "regen.ecocredit.v1.Msg",
                        "CreateOrUpdateApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateProjectEnrollment allows a credit class issuer to evaluate a project
        /// application - either approving, requesting changes to, or
        /// rejecting it, or to terminate an existing enrollment.
        /// Any issuer in the credit class may update the project credit
        /// class enrollment status using this method. If more sophisticated rules are
        /// required to coordinate between different issuers, the credit class admin
        /// should set up an on or off-chain governance process to coordinate this.
        /// Issuers may not admit projects into credit classes using this method
        /// without the project first creating an application. For an issuer to
        /// admit a project into a credit class without an
        /// application the CreateProject method should be used instead.
        ///
        /// If a project has not yet been accepted then the issuer may change the
        /// status to either changes requested, accepted or rejected. If the status
        /// is already accepted, the issuer may only change the status to terminated.
        /// Whenever a project is rejected or terminated, the project's enrollment
        /// the enrollment state will be deleted and the project may apply again
        /// to the same credit class in the future.
        ///
        /// Since Revision 3
        pub async fn update_project_enrollment(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateProjectEnrollment>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateProjectEnrollmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateProjectEnrollment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateProjectEnrollment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CreateBatch creates a new batch of credits under the given project with a
        /// start and end date representing the monitoring period, a list of credits to
        /// be issued with each issuance specifying a recipient, the amount of tradable
        /// and retired credits, and the retirement jurisdiction (if credits are to be
        /// retired upon receipt), and optional metadata. The credit batch creator must
        /// be listed as an approved issuer within the credit class of the project that
        /// the credits are being issued under.
        ///
        /// The default behavior is for a new credit batch to be "sealed" as opposed to
        /// being "open". When a credit batch is "open", new credits can be dynamically
        /// minted to the credit batch following the creation of the credit batch. This
        /// "open" option should only be set to true when bridging credits from another
        /// chain or registry as a result of a bridge operation and is not intended for
        /// native credit issuance.
        pub async fn create_batch(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCreateBatch>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCreateBatchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/CreateBatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "CreateBatch"));
            self.inner.unary(req, path, codec).await
        }
        /// MintBatchCredits dynamically mints credits to an "open" credit batch. This
        /// feature is only meant to be used when bridging credits from another chain
        /// or registry and is not intended for native credit issuance. When bridging
        /// credits from the same vintage (or monitoring period) as an existing credit
        /// batch, the credits can be dynamically minted to the existing credit batch
        /// if the credit batch is "open".
        pub async fn mint_batch_credits(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMintBatchCredits>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMintBatchCreditsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/MintBatchCredits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "MintBatchCredits"));
            self.inner.unary(req, path, codec).await
        }
        /// MsgSealBatch seals an "open" credit batch. Once a credit batch is sealed
        /// (i.e. once "open" is set to false), credits can no longer be dynamically
        /// minted to the credit batch. A sealed credit batch cannot be unsealed and
        /// only the credit batch issuer can seal a credit batch.
        pub async fn seal_batch(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSealBatch>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSealBatchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/SealBatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "SealBatch"));
            self.inner.unary(req, path, codec).await
        }
        /// Send sends a specified amount of tradable credits from the credit owner's
        /// account to another account. Sent credits can either remain tradable or be
        /// retired upon receipt.
        pub async fn send(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSend>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/Send",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "Send"));
            self.inner.unary(req, path, codec).await
        }
        /// Retire retires a specified amount of tradable credits, removing the amount
        /// from the credit owner's tradable balance and adding it to their retired
        /// balance. Retiring credits is permanent and implies the credits are being
        /// consumed as a offset.
        pub async fn retire(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRetire>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRetireResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/Retire",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "Retire"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel cancels a specified amount of tradable credits, removing the amount
        /// from the credit owner's tradable balance and removing the amount from the
        /// credit batch's tradable supply. Cancelling credits is permanent and implies
        /// the credits have been moved to another chain or registry.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCancel>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCancelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "Cancel"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateClassAdmin updates the credit class admin. Only the admin of the
        /// credit class can update the credit class.
        pub async fn update_class_admin(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateClassAdmin>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateClassAdminResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateClassAdmin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateClassAdmin"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateClassIssuers updates the credit class issuer list. Only the admin of
        /// the credit class can update the credit class.
        pub async fn update_class_issuers(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateClassIssuers>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateClassIssuersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateClassIssuers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateClassIssuers"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateClassMetadata updates the credit class metadata. Only the admin of
        /// the credit class can update the credit class.
        pub async fn update_class_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateClassMetadata>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateClassMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateClassMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateClassMetadata"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateProjectAdmin updates the project admin address. Only the admin of the
        /// project can update the project.
        pub async fn update_project_admin(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateProjectAdmin>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateProjectAdminResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateProjectAdmin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateProjectAdmin"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateProjectMetadata updates the project metadata. Only the admin of the
        /// project can update the project.
        pub async fn update_project_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateProjectMetadata>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateProjectMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateProjectMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateProjectMetadata"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateBatchMetadata updates the batch metadata. Only an "open" batch can be
        /// updated and only the issuer of the batch can update the batch.
        ///
        /// Since Revision 2
        pub async fn update_batch_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateBatchMetadata>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateBatchMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateBatchMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateBatchMetadata"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bridge processes credits being sent back to the source chain. When credits
        /// are sent back to the source chain, the credits are cancelled and an event
        /// is emitted to be handled by an external bridge service.
        pub async fn bridge(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgBridge>,
        ) -> std::result::Result<
            tonic::Response<super::MsgBridgeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/Bridge",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "Bridge"));
            self.inner.unary(req, path, codec).await
        }
        /// BridgeReceive processes credits being sent from another chain. When the
        /// credits are sent from the same vintage as an existing credit batch within
        /// the scope of the provided credit class, the credits will be minted to the
        /// existing credit batch, otherwise the credits will be issued in a new credit
        /// batch. The new credit batch will be created under an existing project if a
        /// project with a matching reference id already exists within the scope of the
        /// credit class, otherwise a new project will be created.
        pub async fn bridge_receive(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgBridgeReceive>,
        ) -> std::result::Result<
            tonic::Response<super::MsgBridgeReceiveResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/BridgeReceive",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "BridgeReceive"));
            self.inner.unary(req, path, codec).await
        }
        /// AddCreditType is a governance method that allows the addition of new
        /// credit types to the network.
        ///
        /// Since Revision 2
        pub async fn add_credit_type(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAddCreditType>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAddCreditTypeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/AddCreditType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "AddCreditType"));
            self.inner.unary(req, path, codec).await
        }
        /// SetClassCreatorAllowlist is a governance method that updates the class
        /// creator allowlist enabled setting. When enabled, only addresses listed in
        /// the allowlist can create credit classes. When disabled, any address can
        /// create credit classes.
        ///
        /// Since Revision 2
        pub async fn set_class_creator_allowlist(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgSetClassCreatorAllowlist>,
        ) -> std::result::Result<
            tonic::Response<super::MsgSetClassCreatorAllowlistResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/SetClassCreatorAllowlist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Msg", "SetClassCreatorAllowlist"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// AddClassCreator is a governance method that allows the addition of a new
        /// address to the class creation allowlist.
        ///
        /// Since Revision 2
        pub async fn add_class_creator(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAddClassCreator>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAddClassCreatorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/AddClassCreator",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "AddClassCreator"));
            self.inner.unary(req, path, codec).await
        }
        /// RemoveClassCreator is a governance method that removes an
        /// address from the class creation allowlist.
        ///
        /// Since Revision 2
        pub async fn remove_class_creator(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRemoveClassCreator>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRemoveClassCreatorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/RemoveClassCreator",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "RemoveClassCreator"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateClassFee is a governance method that allows for updating the credit
        /// class creation fee. If no fee is specified in the request, the credit
        /// class creation fee will be removed and no fee will be required to create
        /// a credit class.
        ///
        /// Since Revision 2
        pub async fn update_class_fee(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateClassFee>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateClassFeeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateClassFee",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateClassFee"));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateProjectFee is a governance method that allows for updating the
        /// project creation fee. If no fee is specified in the request, the project
        /// creation fee will be removed and no fee will be required to create a
        /// project.
        ///
        /// Since Revision 3
        pub async fn update_project_fee(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateProjectFee>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateProjectFeeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/UpdateProjectFee",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "UpdateProjectFee"));
            self.inner.unary(req, path, codec).await
        }
        /// AddAllowedBridgeChain is a governance method that allows for the
        /// addition of a chain to bridge ecocredits to.
        ///
        /// Since Revision 2
        pub async fn add_allowed_bridge_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAddAllowedBridgeChain>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAddAllowedBridgeChainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/AddAllowedBridgeChain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Msg", "AddAllowedBridgeChain"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// RemoveAllowedBridgeChain is a governance method that allows for the
        /// removal of a chain to bridge ecocredits to.
        ///
        /// Since Revision 2
        pub async fn remove_allowed_bridge_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRemoveAllowedBridgeChain>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRemoveAllowedBridgeChainResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/RemoveAllowedBridgeChain",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Msg", "RemoveAllowedBridgeChain"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// BurnRegen burns REGEN tokens to account for platform fees when creating or transferring credits.
        ///
        /// Since Revision 3
        pub async fn burn_regen(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgBurnRegen>,
        ) -> std::result::Result<
            tonic::Response<super::MsgBurnRegenResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Msg/BurnRegen",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Msg", "BurnRegen"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// EventCreateClass is an event emitted when a credit class is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCreateClass {
    /// class_id is the unique identifier of the credit class.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
}
/// EventCreateProject is an event emitted when a project is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCreateProject {
    /// project_id is the unique identifier of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
}
/// EventCreateBatch is an event emitted when a credit batch is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCreateBatch {
    /// batch_denom is the unique identifier of the credit batch.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
    /// origin_tx is the transaction from another chain or registry that triggered
    /// the creation of the credit batch.
    #[prost(message, optional, tag = "2")]
    pub origin_tx: ::core::option::Option<OriginTx>,
}
/// EventMint is an event emitted when credits are minted either when creating a
/// credit batch or when bridging assets from another chain or registry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMint {
    /// batch_denom is the unique identifier of the credit batch within which the
    /// credits were minted.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
    /// tradable_amount is the amount of tradable credits minted.
    #[prost(string, tag = "2")]
    pub tradable_amount: ::prost::alloc::string::String,
    /// retired_amount is the amount of retired credits minted.
    #[prost(string, tag = "3")]
    pub retired_amount: ::prost::alloc::string::String,
}
/// EventMintBatchCredits is an event emitted when credits are minted to an
/// existing open credit batch.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMintBatchCredits {
    /// batch_denom is the unique identifier of the credit batch within which the
    /// credits were minted.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
    /// origin_tx is the transaction from another chain or registry that triggered
    /// the minting of credits within the credit batch.
    #[prost(message, optional, tag = "2")]
    pub origin_tx: ::core::option::Option<OriginTx>,
}
/// EventTransfer is an event emitted when credits are transferred from one
/// account to another including transfers to or from a module account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTransfer {
    /// sender is the sender of the credits. In the case that the credits were
    /// transferred from a base account, this will be the account address. In the
    /// case that the credits were transferred from a module, this will be the
    /// module address (i.e. either the ecocredit module or basket submodule).
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    /// recipient is the recipient of the credits. In the case that the credits
    /// were transferred to a base account, this will be the account address. In
    /// the case that the credits were transferred to a module, this will be the
    /// module address (i.e. either the ecocredit module or basket submodule).
    #[prost(string, tag = "2")]
    pub recipient: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch.
    #[prost(string, tag = "3")]
    pub batch_denom: ::prost::alloc::string::String,
    /// tradable_amount is the decimal number of tradable credits received.
    #[prost(string, tag = "4")]
    pub tradable_amount: ::prost::alloc::string::String,
    /// retired_amount is the decimal number of retired credits received.
    #[prost(string, tag = "5")]
    pub retired_amount: ::prost::alloc::string::String,
}
/// EventRetire is an event emitted when credits are retired. When credits are
/// retired from multiple batches in the same transaction, a separate event is
/// emitted for each batch_denom. This allows for easier indexing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRetire {
    /// owner is the address of the account that owns the retired credits. This
    /// will be the account receiving credits in the case that credits were retired
    /// upon issuance using Msg/CreateBatch, retired upon transfer using Msg/Send,
    /// retired upon taking from a basket using basket.Msg/Take, or retired upon
    /// purchase using marketplace.Msg/BuyDirect.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch within which the
    /// credits were retired.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
    /// amount is the decimal number of credits that have been retired.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// jurisdiction is the jurisdiction of the beneficiary or buyer of the retired
    /// credits. It is a string of the form
    /// <country-code>\[-<sub-national-code>[ <postal-code>]\], with the first two
    /// fields conforming to ISO 3166-2, and postal-code being up to 64
    /// alphanumeric characters.
    #[prost(string, tag = "4")]
    pub jurisdiction: ::prost::alloc::string::String,
    /// reason is any arbitrary string that specifies the reason for retiring
    /// credits.
    ///
    /// Since Revision 2
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// EventCancel is an event emitted when credits are cancelled. When credits are
/// cancelled from multiple batches in the same transaction, a separate event is
/// emitted for each batch_denom. This allows for easier indexing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCancel {
    /// owner is the address of the account that cancelled the credits.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch within which the
    /// credits were cancelled.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
    /// amount is the decimal number of credits that have been cancelled.
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// reason is the reason the credits were cancelled.
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
}
/// EventUpdateClassAdmin is emitted when the admin address of a credit class is
/// changed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateClassAdmin {
    /// class_id is the unique identifier of the class that was updated.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
}
/// EventUpdateClassIssuers is emitted when the issuer list for a credit class
/// is updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateClassIssuers {
    /// class_id is the unique identifier of the class that was updated.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
}
/// EventUpdateClassMetadata is emitted when the credit class metadata is
/// changed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateClassMetadata {
    /// class_id is the unique identifier of the class that was updated.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
}
/// EventUpdateProjectAdmin is emitted when the project admin is changed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateProjectAdmin {
    /// project_id is the unique identifier of the project that was updated.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
}
/// EventUpdateProjectMetadata is emitted when the project metadata is changed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateProjectMetadata {
    /// project_id is the unique identifier of the project that was updated.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
}
/// EventUpdateBatchMetadata is emitted when the credit batch metadata is
/// changed.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateBatchMetadata {
    /// batch_denom is the unique identifier of the batch that was updated.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// EventSealBatch is emitted when a batch is sealed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSealBatch {
    /// batch_denom is the denom of the batch that was sealed.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// EventAddCreditType is emitted when governance approves a new credit type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventAddCreditType {
    /// abbreviation is the abbreviation of the credit type.
    #[prost(string, tag = "1")]
    pub abbreviation: ::prost::alloc::string::String,
}
/// EventBridge is emitted when credits are bridged to another chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventBridge {
    /// target is the target chain.
    #[prost(string, tag = "1")]
    pub target: ::prost::alloc::string::String,
    /// recipient is the recipient address.
    #[prost(string, tag = "2")]
    pub recipient: ::prost::alloc::string::String,
    /// contract is the contract address.
    #[prost(string, tag = "3")]
    pub contract: ::prost::alloc::string::String,
    /// amount is the amount of credits.
    #[prost(string, tag = "4")]
    pub amount: ::prost::alloc::string::String,
    /// owner is the owner address.
    ///
    /// Since Revision 1
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    /// batch_denom is the credit batch denom.
    ///
    /// Since Revision 3
    #[prost(string, tag = "6")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// EventBridgeReceive is emitted when credits are bridged from another chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventBridgeReceive {
    /// project_id is the unique identifier of the project that was either created
    /// or the existing project within which the credit batch exists.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch either created
    /// or within which the credits were dynamically minted.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
    /// amount is the amount of credits.
    ///
    /// Since Revision 3
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    /// origin_tx is the transaction from another chain or registry that triggered
    /// the minting of credits within the credit batch.
    ///
    /// Since Revision 3
    #[prost(message, optional, tag = "4")]
    pub origin_tx: ::core::option::Option<OriginTx>,
}
/// EventBurnRegen is an event emitted when REGEN is burned to account for credit origination, transfer, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventBurnRegen {
    /// burner is the address that burned REGEN.
    #[prost(string, tag = "1")]
    pub burner: ::prost::alloc::string::String,
    /// amount is the integer amount of uregen burned.
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    /// reason is the reason for the burn.
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
/// EventUpdateApplication is emitted when a project admin creates, updates
/// or withdraws a project's application to a credit class.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateApplication {
    /// project_id is the unique identifier of the project that was updated.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the class that was updated.
    #[prost(string, tag = "2")]
    pub class_id: ::prost::alloc::string::String,
    /// action is the action that was taken on the application.
    #[prost(enumeration = "event_update_application::Action", tag = "3")]
    pub action: i32,
    /// new_application_metadata is any new application metadata.
    #[prost(string, tag = "4")]
    pub new_application_metadata: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EventUpdateApplication`.
pub mod event_update_application {
    /// Action describes an action taken on an application.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// ACTION_UNSPECIFIED is the default value for the action and is invalid.
        Unspecified = 0,
        /// ACTION_CREATE is the action taken when a project admin creates an
        /// application to a credit class.
        Create = 1,
        /// ACTION_UPDATE is the action taken when a project admin updates an
        /// application to a credit class.
        Update = 2,
        /// ACTION_WITHDRAW is the action taken when a project admin withdraws an
        /// application to a credit class.
        Withdraw = 3,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTION_UNSPECIFIED",
                Self::Create => "ACTION_CREATE",
                Self::Update => "ACTION_UPDATE",
                Self::Withdraw => "ACTION_WITHDRAW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTION_CREATE" => Some(Self::Create),
                "ACTION_UPDATE" => Some(Self::Update),
                "ACTION_WITHDRAW" => Some(Self::Withdraw),
                _ => None,
            }
        }
    }
}
/// EventUpdateProjectEnrollment is emitted when a credit class issuer updates
/// the enrollment status of a project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventUpdateProjectEnrollment {
    /// issuer is the address of the credit class issuer which evaluated the
    /// project.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// project_id is the unique identifier of the project that was evaluated.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the class in which the project was
    /// evaluated.
    #[prost(string, tag = "3")]
    pub class_id: ::prost::alloc::string::String,
    /// old_status is the old status of the project class relationship.
    #[prost(enumeration = "ProjectEnrollmentStatus", tag = "4")]
    pub old_status: i32,
    /// new_status is the new status of the project class relationship.
    #[prost(enumeration = "ProjectEnrollmentStatus", tag = "5")]
    pub new_status: i32,
    /// new_enrollment_metadata is any new enrollment metadata.
    #[prost(string, tag = "6")]
    pub new_enrollment_metadata: ::prost::alloc::string::String,
}
/// QueryClassesRequest is the Query/Classes request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassesRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryClassesResponse is the Query/Classes response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassesResponse {
    /// classes are the fetched credit classes.
    #[prost(message, repeated, tag = "1")]
    pub classes: ::prost::alloc::vec::Vec<ClassInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryClassesByAdminRequest is the Query/ClassesByAdmin request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassesByAdminRequest {
    /// admin is the address of the admin of the class.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryClassesByAdminResponse is the Query/ClassesByAdmin response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassesByAdminResponse {
    /// classes are the fetched credit classes.
    #[prost(message, repeated, tag = "1")]
    pub classes: ::prost::alloc::vec::Vec<ClassInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryClassRequest is the Query/Class request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassRequest {
    /// class_id is the unique identifier of the credit class to query.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
}
/// QueryClassResponse is the Query/Class request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassResponse {
    /// class is the fetched credit class.
    #[prost(message, optional, tag = "1")]
    pub class: ::core::option::Option<ClassInfo>,
}
/// QueryClassIssuersRequest is the Query/ClassIssuers request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassIssuersRequest {
    /// class_id is the unique identifier of the credit class to query.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryClassIssuersRequest is the Query/ClassIssuers response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassIssuersResponse {
    /// issuers is a list of issuers for the credit class
    #[prost(string, repeated, tag = "1")]
    pub issuers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryProjectsRequest is the Query/Projects request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryProjectsResponse is the Query/Projects response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsResponse {
    /// projects are the fetched projects.
    #[prost(message, repeated, tag = "1")]
    pub projects: ::prost::alloc::vec::Vec<ProjectInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryProjectsByClassRequest is the Query/ProjectsByClass request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsByClassRequest {
    /// class_id is the unique identifier of the credit class to query.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryProjectsByClassResponse is the Query/ProjectsByClass response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsByClassResponse {
    /// projects are the fetched projects.
    #[prost(message, repeated, tag = "1")]
    pub projects: ::prost::alloc::vec::Vec<ProjectInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryProjectsByReferenceIdRequest is the Query/ProjectsByReferenceId request
/// type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsByReferenceIdRequest {
    /// reference_id is the project reference id.
    #[prost(string, tag = "1")]
    pub reference_id: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryProjectsByReferenceIdResponse is the Query/ProjectsByReferenceId
/// response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsByReferenceIdResponse {
    /// projects are the fetched projects.
    #[prost(message, repeated, tag = "1")]
    pub projects: ::prost::alloc::vec::Vec<ProjectInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryProjectsByAdminRequest is the Query/ProjectByAdmin request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsByAdminRequest {
    /// admin is the account address of project admin.
    #[prost(string, tag = "1")]
    pub admin: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryProjectsByAdminResponse is the Query/ProjectByAdmin response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectsByAdminResponse {
    /// projects are the fetched projects.
    #[prost(message, repeated, tag = "1")]
    pub projects: ::prost::alloc::vec::Vec<ProjectInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryProjectRequest is the Query/Project request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectRequest {
    /// project_id is the unique identifier of the project to query.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
}
/// QueryProjectResponse is the Query/Project response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectResponse {
    /// project is the fetched project.
    #[prost(message, optional, tag = "1")]
    pub project: ::core::option::Option<ProjectInfo>,
}
/// QueryBatchesRequest is the Query/Batches request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryBatchesResponse is the Query/Batches response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesResponse {
    /// batches are the fetched credit batches.
    #[prost(message, repeated, tag = "1")]
    pub batches: ::prost::alloc::vec::Vec<BatchInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryBatchesByIssuerRequest is the Query/BatchesByIssuer request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesByIssuerRequest {
    /// issuer is the address that issued the batch
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryBatchesByIssuerResponse is the Query/BatchesByIssuer response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesByIssuerResponse {
    /// batches are the fetched credit batches.
    #[prost(message, repeated, tag = "1")]
    pub batches: ::prost::alloc::vec::Vec<BatchInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryBatchesByClassRequest is the Query/BatchesByClass request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesByClassRequest {
    /// class_id is the unique identifier of the credit class to query.
    #[prost(string, tag = "1")]
    pub class_id: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryBatchesByProjectRequest is the Query/BatchesByProject request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesByProjectRequest {
    /// project_id is the unique identifier of the project to query.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryBatchesByProjectResponse is the Query/BatchesByProject response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesByProjectResponse {
    /// batches are the fetched credit batches.
    #[prost(message, repeated, tag = "1")]
    pub batches: ::prost::alloc::vec::Vec<BatchInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryBatchesByClassResponse is the Query/BatchesByClass response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchesByClassResponse {
    /// batches are the fetched credit batches.
    #[prost(message, repeated, tag = "1")]
    pub batches: ::prost::alloc::vec::Vec<BatchInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryBatchRequest is the Query/Batch request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchRequest {
    /// batch_denom is the unique identifier of the credit batch to query.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// QueryBatchResponse is the Query/Batch response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBatchResponse {
    /// batch is the fetched credit batch.
    #[prost(message, optional, tag = "1")]
    pub batch: ::core::option::Option<BatchInfo>,
}
/// QueryBalanceRequest is the Query/Balance request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalanceRequest {
    /// address is the address of the account whose balance is being queried.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch to query.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// QueryBalanceResponse is the Query/Balance response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalanceResponse {
    /// balance is the balance of the given account.
    #[prost(message, optional, tag = "1")]
    pub balance: ::core::option::Option<BatchBalanceInfo>,
}
/// QueryBalancesRequest is the Query/Balances request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalancesRequest {
    /// address is the address of the account whose balance is being queried.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryBalancesResponse is the Query/Balances response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalancesResponse {
    /// balances are a list of balances from different credit batches that the
    /// account holds.
    #[prost(message, repeated, tag = "1")]
    pub balances: ::prost::alloc::vec::Vec<BatchBalanceInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryBalancesByBatchRequest is the Query/BalancesByBatch request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalancesByBatchRequest {
    /// batch_denom is the denom of the batch to query by.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryBalancesByBatchResponse is the Query/BalancesByBatch response type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalancesByBatchResponse {
    /// balances are a list of balances from different credit batches that the
    /// account holds.
    #[prost(message, repeated, tag = "1")]
    pub balances: ::prost::alloc::vec::Vec<BatchBalanceInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryAllBalancesRequest is the Query/AllBalances request type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllBalancesRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAllBalancesResponse is the Query/AllBalances response type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllBalancesResponse {
    /// balances are a list of balances from different credit batches that the
    /// account holds.
    #[prost(message, repeated, tag = "1")]
    pub balances: ::prost::alloc::vec::Vec<BatchBalanceInfo>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QuerySupplyRequest is the Query/Supply request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySupplyRequest {
    /// batch_denom is the unique identifier of the credit batch to query.
    #[prost(string, tag = "1")]
    pub batch_denom: ::prost::alloc::string::String,
}
/// QuerySupplyResponse is the Query/Supply response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySupplyResponse {
    /// tradable_amount is the decimal number of tradable credits in the batch
    /// supply.
    #[prost(string, tag = "1")]
    pub tradable_amount: ::prost::alloc::string::String,
    /// retired_amount is the decimal number of retired credits in the batch
    /// supply.
    #[prost(string, tag = "2")]
    pub retired_amount: ::prost::alloc::string::String,
    /// cancelled_amount is the decimal number of cancelled credits in the batch
    /// supply.
    #[prost(string, tag = "3")]
    pub cancelled_amount: ::prost::alloc::string::String,
}
/// QueryCreditTypesRequest is the Query/Credit_Types request type
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryCreditTypesRequest {}
/// QueryCreditTypesRequest is the Query/Credit_Types response type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCreditTypesResponse {
    /// credit_types are the fetched credit types.
    #[prost(message, repeated, tag = "1")]
    pub credit_types: ::prost::alloc::vec::Vec<CreditType>,
}
/// QueryParamsRequest is the Query/Params request type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
/// QueryParamsResponse is the Query/Params response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params defines the parameters of the ecocredit module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
/// QueryCreditTypeRequest is the Query/CreditType request type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCreditTypeRequest {
    /// abbreviation is the abbreviation of the credit type.
    #[prost(string, tag = "1")]
    pub abbreviation: ::prost::alloc::string::String,
}
/// QueryCreditTypeResponse is the Query/CreditType response type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCreditTypeResponse {
    /// credit_type is the fetched credit type.
    #[prost(message, optional, tag = "1")]
    pub credit_type: ::core::option::Option<CreditType>,
}
/// ClassInfo is the human-readable credit class information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClassInfo {
    /// id is the unique identifier of the credit class.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// admin is the admin of the credit class.
    #[prost(string, tag = "2")]
    pub admin: ::prost::alloc::string::String,
    /// metadata is the arbitrary metadata attached to the credit class.
    #[prost(string, tag = "3")]
    pub metadata: ::prost::alloc::string::String,
    /// credit_type_abbrev is the abbreviation of the credit type within which this
    /// credit class was created.
    #[prost(string, tag = "4")]
    pub credit_type_abbrev: ::prost::alloc::string::String,
}
/// ProjectInfo is the human-readable project information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectInfo {
    /// id is the unique identifier of the project.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// admin is the admin of the project.
    #[prost(string, tag = "2")]
    pub admin: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the credit class within which the
    /// project was created.
    #[prost(string, tag = "3")]
    pub class_id: ::prost::alloc::string::String,
    /// jurisdiction is the jurisdiction of the project. Full documentation can be
    /// found in MsgCreateProject.jurisdiction.
    #[prost(string, tag = "4")]
    pub jurisdiction: ::prost::alloc::string::String,
    /// metadata is the arbitrary metadata attached to the project.
    #[prost(string, tag = "5")]
    pub metadata: ::prost::alloc::string::String,
    /// reference_id is any arbitrary string that can be use to reference project.
    #[prost(string, tag = "6")]
    pub reference_id: ::prost::alloc::string::String,
}
/// BatchInfo is the human-readable credit batch information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchInfo {
    /// issuer is the address that created the batch and the address authorized to
    /// mint new credits to the credit batch if the credit batch is open.
    #[prost(string, tag = "1")]
    pub issuer: ::prost::alloc::string::String,
    /// project_id is the unique identifier of the project within which this credit
    /// batch was created.
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    /// denom is the unique identifier of the credit batch formed from the project
    /// name, batch sequence number and dates.
    #[prost(string, tag = "3")]
    pub denom: ::prost::alloc::string::String,
    /// metadata is any arbitrary metadata attached to the credit batch.
    #[prost(string, tag = "4")]
    pub metadata: ::prost::alloc::string::String,
    /// start_date is the beginning of the period during which this credit batch
    /// was quantified and verified.
    #[prost(message, optional, tag = "5")]
    pub start_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// end_date is the end of the period during which this credit batch was
    /// quantified and verified.
    #[prost(message, optional, tag = "6")]
    pub end_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// issuance_date is the timestamp when the credit batch was issued.
    #[prost(message, optional, tag = "7")]
    pub issuance_date: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// open determines whether or not the credit batch is open, i.e. whether or
    /// not new credits can be minted to the credit batch.
    #[prost(bool, tag = "8")]
    pub open: bool,
}
/// BatchBalanceInfo is the human-readable batch balance information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchBalanceInfo {
    /// address is the address of the account that owns the credits.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// batch_denom is the unique identifier of the credit batch.
    #[prost(string, tag = "2")]
    pub batch_denom: ::prost::alloc::string::String,
    /// tradable_amount is the total number of tradable credits owned by address.
    #[prost(string, tag = "3")]
    pub tradable_amount: ::prost::alloc::string::String,
    /// retired_amount is the total number of retired credits owned by address.
    #[prost(string, tag = "4")]
    pub retired_amount: ::prost::alloc::string::String,
    /// escrowed_amount is the total number of escrowed credits owned by address
    /// and held in escrow by the marketplace. Credits are held in escrow when a
    /// sell order is created and taken out of escrow when the sell order is either
    /// cancelled, updated with a reduced quantity, or processed.
    #[prost(string, tag = "5")]
    pub escrowed_amount: ::prost::alloc::string::String,
}
/// QueryClassCreatorAllowlistRequest is the Query/ClassCreatorAllowlist request
/// type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryClassCreatorAllowlistRequest {}
/// QueryClassCreatorAllowlistResponse is the Query/ClassCreatorAllowlist
/// response type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryClassCreatorAllowlistResponse {
    /// enabled determines whether or not the allowlist for creating credit classes
    /// is enabled.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// QueryAllowedClassCreatorsRequest is the Query/AllowedClassCreators request
/// type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllowedClassCreatorsRequest {
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAllowedClassCreatorsResponse is the Query/AllowedClassCreators response
/// type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllowedClassCreatorsResponse {
    /// class_creators is the list of allowed credit class creators.
    #[prost(string, repeated, tag = "1")]
    pub class_creators: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryClassFeeRequest is the Query/ClassFee request type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryClassFeeRequest {}
/// QueryClassFeeResponse is the Query/ClassFee response type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryClassFeeResponse {
    /// fee is the credit class creation fee. If not set, a credit class creation
    /// fee is not required.
    #[prost(message, optional, tag = "1")]
    pub fee: ::core::option::Option<::cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
/// QueryAllowedBridgeChainsRequest is the Query/AllowedBridgeChains request
/// type.
///
/// Since Revision 2
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryAllowedBridgeChainsRequest {}
/// QueryAllowedBridgeChainsResponse is the Query/AllowedBridgeChains response
/// type.
///
/// Since Revision 2
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllowedBridgeChainsResponse {
    /// allowed_bridge_chains is a list of chains that are allowed to be used in
    /// bridge operations.
    #[prost(string, repeated, tag = "1")]
    pub allowed_bridge_chains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// QueryProjectEnrollmentRequest is the Query/ProjectEnrollment request type.
///
/// Since Revision 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectEnrollmentRequest {
    /// project_id is the unique identifier of the project to query.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// class_id is the unique identifier of the credit class to query.
    #[prost(string, tag = "2")]
    pub class_id: ::prost::alloc::string::String,
}
/// QueryProjectEnrollmentResponse is the Query/ProjectEnrollment response type.
///
/// Since Revision 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectEnrollmentResponse {
    /// project_class is the fetched project class relationship.
    #[prost(message, optional, tag = "1")]
    pub project_class: ::core::option::Option<ProjectEnrollment>,
}
/// QueryProjectEnrollmentsRequest is the Query/ProjectEnrollments request type.
///
/// Since Revision 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectEnrollmentsRequest {
    /// project_id is the unique identifier of the project to query.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// pagination defines an optional pagination for the request.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryProjectEnrollmentsResponse is the Query/ProjectEnrollments response type.
///
/// Since Revision 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProjectEnrollmentsResponse {
    /// enrollments are the fetched project credit class enrollments.
    #[prost(message, repeated, tag = "1")]
    pub enrollments: ::prost::alloc::vec::Vec<ProjectEnrollment>,
    /// pagination defines the pagination in the response.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg is the regen.ecocredit.v1 Query service.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Classes queries for all credit classes with pagination.
        pub async fn classes(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryClassesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClassesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Classes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Classes"));
            self.inner.unary(req, path, codec).await
        }
        /// ClassesByAdmin queries for all credit classes with a specific admin
        /// address.
        pub async fn classes_by_admin(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryClassesByAdminRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClassesByAdminResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ClassesByAdmin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "ClassesByAdmin"));
            self.inner.unary(req, path, codec).await
        }
        /// Class queries for information on a credit class.
        pub async fn class(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryClassRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClassResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Class",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Class"));
            self.inner.unary(req, path, codec).await
        }
        /// ClassIssuers queries for the addresses of the issuers for a credit class.
        pub async fn class_issuers(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryClassIssuersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClassIssuersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ClassIssuers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "ClassIssuers"));
            self.inner.unary(req, path, codec).await
        }
        /// Projects queries for all projects with pagination.
        pub async fn projects(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Projects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Projects"));
            self.inner.unary(req, path, codec).await
        }
        /// ProjectsByClass queries for all projects within a class with pagination.
        pub async fn projects_by_class(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProjectsByClassRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProjectsByClassResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ProjectsByClass",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "ProjectsByClass"));
            self.inner.unary(req, path, codec).await
        }
        /// ProjectsByReferenceId queries for all projects by reference-id with
        /// pagination.
        pub async fn projects_by_reference_id(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProjectsByReferenceIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProjectsByReferenceIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ProjectsByReferenceId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Query", "ProjectsByReferenceId"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ProjectsByAdmin queries for all projects by admin with
        /// pagination.
        pub async fn projects_by_admin(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProjectsByAdminRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProjectsByAdminResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ProjectsByAdmin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "ProjectsByAdmin"));
            self.inner.unary(req, path, codec).await
        }
        /// Project queries for information on a project.
        pub async fn project(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Project",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Project"));
            self.inner.unary(req, path, codec).await
        }
        /// Batches queries for all batches with pagination.
        pub async fn batches(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBatchesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBatchesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Batches",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Batches"));
            self.inner.unary(req, path, codec).await
        }
        /// BatchesByIssuer queries all batches issued from a given issuer address.
        pub async fn batches_by_issuer(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBatchesByIssuerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBatchesByIssuerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/BatchesByIssuer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "BatchesByIssuer"));
            self.inner.unary(req, path, codec).await
        }
        /// BatchesByClass queries all batches issued from a given class.
        pub async fn batches_by_class(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBatchesByClassRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBatchesByClassResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/BatchesByClass",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "BatchesByClass"));
            self.inner.unary(req, path, codec).await
        }
        /// BatchesByProject queries for all batches from a given project with
        /// pagination.
        pub async fn batches_by_project(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBatchesByProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBatchesByProjectResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/BatchesByProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "BatchesByProject"));
            self.inner.unary(req, path, codec).await
        }
        /// Batch queries for information on a credit batch.
        pub async fn batch(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBatchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBatchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Batch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Batch"));
            self.inner.unary(req, path, codec).await
        }
        /// Balance queries the balance (both tradable and retired) of a given credit
        /// batch for a given account address.
        pub async fn balance(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBalanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBalanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Balance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Balance"));
            self.inner.unary(req, path, codec).await
        }
        /// Balances queries all credit balances the given account holds.
        pub async fn balances(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBalancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBalancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Balances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Balances"));
            self.inner.unary(req, path, codec).await
        }
        /// BalancesByBatch queries all credit balances from a given batch.
        ///
        /// Since Revision 2
        pub async fn balances_by_batch(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryBalancesByBatchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryBalancesByBatchResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/BalancesByBatch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "BalancesByBatch"));
            self.inner.unary(req, path, codec).await
        }
        /// AllBalances queries all credit balances.
        ///
        /// Since Revision 2
        pub async fn all_balances(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllBalancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllBalancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/AllBalances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "AllBalances"));
            self.inner.unary(req, path, codec).await
        }
        /// Supply queries the tradable and retired supply of a credit batch.
        pub async fn supply(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySupplyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySupplyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Supply",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Supply"));
            self.inner.unary(req, path, codec).await
        }
        /// CreditTypes returns the list of allowed types that credit classes can have.
        /// See Types/CreditType for more details.
        pub async fn credit_types(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryCreditTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCreditTypesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/CreditTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "CreditTypes"));
            self.inner.unary(req, path, codec).await
        }
        /// Params queries the ecocredit module parameters.
        ///
        /// Deprecated (Since Revision 2): This rpc will be removed in the next
        /// version.
        #[deprecated]
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/Params",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
        /// CreditType queries credit type information by abbreviation.
        pub async fn credit_type(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryCreditTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCreditTypeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/CreditType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "CreditType"));
            self.inner.unary(req, path, codec).await
        }
        /// ClassCreatorAllowlist queries the credit class creator allowlist
        /// enabled setting.
        ///
        /// Since Revision 2
        pub async fn class_creator_allowlist(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryClassCreatorAllowlistRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClassCreatorAllowlistResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ClassCreatorAllowlist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Query", "ClassCreatorAllowlist"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// AllowedClassCreators queries allowed credit class creators list.
        ///
        /// Since Revision 2
        pub async fn allowed_class_creators(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllowedClassCreatorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllowedClassCreatorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/AllowedClassCreators",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Query", "AllowedClassCreators"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ClassFee returns the credit class creation fee. If not set, a credit class
        /// creation fee is not required.
        ///
        /// Since Revision 2
        pub async fn class_fee(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryClassFeeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryClassFeeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ClassFee",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.ecocredit.v1.Query", "ClassFee"));
            self.inner.unary(req, path, codec).await
        }
        /// AllowedBridgeChains queries the list of chains allowed to be used in bridge
        /// operations.
        ///
        /// Since Revision 2
        pub async fn allowed_bridge_chains(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllowedBridgeChainsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllowedBridgeChainsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/AllowedBridgeChains",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Query", "AllowedBridgeChains"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ProjectEnrollment queries information about a project's enrollment in a
        /// credit class.
        ///
        /// Since Revision 3
        pub async fn project_enrollment(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProjectEnrollmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProjectEnrollmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ProjectEnrollment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Query", "ProjectEnrollment"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ProjectEnrollments queries all credit class enrollments associated with a
        /// project.
        pub async fn project_enrollments(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProjectEnrollmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProjectEnrollmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.ecocredit.v1.Query/ProjectEnrollments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.ecocredit.v1.Query", "ProjectEnrollments"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
