// This file is @generated by prost-build.
/// ContentHash specifies a hash-based content identifier for a piece of data.
/// Exactly one of its fields must be set so this message behaves like a oneof.
/// A protobuf oneof was not used because this caused compatibility issues with
/// amino signing.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentHash {
    /// raw specifies "raw" data which does not specify a deterministic, canonical
    /// encoding. Users of these hashes MUST maintain a copy of the hashed data
    /// which is preserved bit by bit. All other content encodings specify a
    /// deterministic, canonical encoding allowing implementations to choose from a
    /// variety of alternative formats for transport and encoding while maintaining
    /// the guarantee that the canonical hash will not change.
    #[prost(message, optional, tag = "1")]
    pub raw: ::core::option::Option<content_hash::Raw>,
    /// graph specifies graph data that conforms to the RDF data model.
    /// The canonicalization algorithm used for an RDF graph is specified by
    /// GraphCanonicalizationAlgorithm.
    #[prost(message, optional, tag = "2")]
    pub graph: ::core::option::Option<content_hash::Graph>,
}
/// Nested message and enum types in `ContentHash`.
pub mod content_hash {
    /// RawVis the content hash type used for raw data.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Raw {
        /// hash represents the hash of the data based on the specified
        /// digest_algorithm. It must be at least 20 bytes long and at most 64 bytes long.
        #[prost(bytes = "vec", tag = "1")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
        /// digest_algorithm represents the hash digest algorithm and should be a non-zero value from the DigestAlgorithm enum.
        #[prost(uint32, tag = "2")]
        pub digest_algorithm: u32,
        /// file_extension represents the file extension for raw data. It can be
        /// must be between 2-6 characters long, must be all lower-case and should represent
        /// the canonical extension for the media type.
        ///
        /// A list of canonical extensions which should be used is provided here
        /// and SHOULD be used by implementations: txt, json, csv, xml, pdf, tiff,
        /// jpg, png, svg, webp, avif, gif, apng, mpeg, mp4, webm, ogg, heic, raw.
        ///
        /// The above list should be updated as new media types come into common usage
        /// especially when there are two or more possible extensions (i.e. jpg vs jpeg or tif vs tiff).
        #[prost(string, tag = "3")]
        pub file_extension: ::prost::alloc::string::String,
    }
    /// Graph is the content hash type used for RDF graph data.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Graph {
        /// hash represents the hash of the data based on the specified
        /// digest_algorithm. It must be at least 20 bytes long and at most 64 bytes long.
        #[prost(bytes = "vec", tag = "1")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
        /// digest_algorithm represents the hash digest algorithm and should be a non-zero value from the DigestAlgorithm enum.
        #[prost(uint32, tag = "2")]
        pub digest_algorithm: u32,
        /// graph_canonicalization_algorithm represents the RDF graph
        /// canonicalization algorithm and should be a non-zero value from the GraphCanonicalizationAlgorithm enum.
        #[prost(uint32, tag = "3")]
        pub canonicalization_algorithm: u32,
        /// merkle_tree is the merkle tree type used for the graph hash, if any and should be a value from the GraphMerkleTree enum
        /// or left unspecified.
        #[prost(uint32, tag = "4")]
        pub merkle_tree: u32,
    }
}
/// ContentHashes contains list of content ContentHash.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentHashes {
    /// data is a list of content hashes which the resolver claims to serve.
    #[prost(message, repeated, tag = "1")]
    pub content_hashes: ::prost::alloc::vec::Vec<ContentHash>,
}
/// DigestAlgorithm is the hash digest algorithm
///
/// With v2, this enum is no longer validated on-chain.
/// However, this enum SHOULD still be used and updated as a registry of known digest
/// algorithms and all implementations should coordinate on these values.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DigestAlgorithm {
    /// unspecified and invalid
    Unspecified = 0,
    /// BLAKE2b-256
    Blake2b256 = 1,
}
impl DigestAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DIGEST_ALGORITHM_UNSPECIFIED",
            Self::Blake2b256 => "DIGEST_ALGORITHM_BLAKE2B_256",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIGEST_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "DIGEST_ALGORITHM_BLAKE2B_256" => Some(Self::Blake2b256),
            _ => None,
        }
    }
}
/// GraphCanonicalizationAlgorithm is the graph canonicalization algorithm
///
/// With v2, this enum is no longer validated on-chain.
/// However, this enum SHOULD still be used and updated as a registry of known canonicalization
/// algorithms and all implementations should coordinate on these values.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GraphCanonicalizationAlgorithm {
    /// unspecified and invalid
    Unspecified = 0,
    /// RDFC 1.0 graph canonicalization algorithm. Essentially the same as URDNA2015 with some
    /// small clarifications around escaping of escape characters.
    Rdfc10 = 1,
}
impl GraphCanonicalizationAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED",
            Self::Rdfc10 => "GRAPH_CANONICALIZATION_ALGORITHM_RDFC_1_0",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "GRAPH_CANONICALIZATION_ALGORITHM_RDFC_1_0" => Some(Self::Rdfc10),
            _ => None,
        }
    }
}
/// GraphMerkleTree is the graph merkle tree type used for hashing, if any.
///
/// With v2, this enum is no longer validated on-chain.
/// However, this enum SHOULD still be used and updated as a registry of known merkle tree
/// types and all implementations should coordinate on these values.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GraphMerkleTree {
    /// unspecified and valid
    NoneUnspecified = 0,
}
impl GraphMerkleTree {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoneUnspecified => "GRAPH_MERKLE_TREE_NONE_UNSPECIFIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GRAPH_MERKLE_TREE_NONE_UNSPECIFIED" => Some(Self::NoneUnspecified),
            _ => None,
        }
    }
}
/// MsgAnchor is the Msg/Anchor request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAnchor {
    /// sender is the address of the sender of the transaction. The sender in
    /// Anchor is not attesting to the veracity of the underlying data. They
    /// can simply be an intermediary providing services.
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    /// content_hash is the content hash for the data to anchor.
    #[prost(message, optional, tag = "2")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// MsgAnchor is the Msg/Anchor response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAnchorResponse {
    /// iri is the IRI of the data that was anchored.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// timestamp is the time at which the data was anchored.
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// MsgAttest is the Msg/Attest request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAttest {
    /// attestor is the addresses of the account attesting to the veracity of the
    /// data. By making an Attest request, the attestor is attesting to the
    /// veracity of the data referenced by the IRI. The precise meaning of this may
    /// vary depending on the underlying data.
    #[prost(string, tag = "1")]
    pub attestor: ::prost::alloc::string::String,
    /// content_hashes are the content hashes for anchored data. Only RDF graph
    /// data can be signed as its data model is intended to specifically convey
    /// semantic meaning.
    #[prost(message, repeated, tag = "2")]
    pub content_hashes: ::prost::alloc::vec::Vec<content_hash::Graph>,
}
/// MsgAttestResponse is the Msg/Attest response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAttestResponse {
    /// iris are the IRIs of the data that was attested to. If the attestor attests
    /// to the same piece of data, the previous attestation will not be updated and
    /// the IRI will not be included in this list.
    #[prost(string, repeated, tag = "1")]
    pub iris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// timestamp is the time at which any new attestations were made.
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// MsgDefineResolver is the Msg/DefineResolver request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDefineResolver {
    /// definer is the address of the account defining the resolver. If
    /// the boolean public is set to true, then any user can register
    /// data with this resolver. If the boolean public is set to false,
    /// then only the definer can register data with this resolver and
    /// must use a feature such as cosmos.authz to authorize other accounts
    /// to register data with this resolver.
    #[prost(string, tag = "1")]
    pub definer: ::prost::alloc::string::String,
    /// resolver_url is a resolver URL.
    ///
    /// If it refers to an HTTP URL, that HTTP service should
    /// respond to a GET request with the IRI of a ContentHash as the path parameter
    /// and return the content if it exists or a 404. For graph data, resolvers
    /// should use the HTTP Accept header to negotiate the RDF serialization
    /// format.
    ///
    /// To use IPFS, the resolver_url ipfs: should be defined with public set to true
    /// and used as the resolver for any data hosted on IPFS. Content hashes must be
    /// adapted to IPFS's CID format. The multicodec raw (0x55) should
    /// be used for all raw content hashes and the multicodec rdfc-1 (0xb403)
    /// should be used for all graph content hashes (unless new canonicalization
    /// or merkle tree algorithms are used which may or may not be supported
    /// by IPFS). Note that IPFS's tools currently do not support creating or
    /// resolving RDFC-1 content hashes so upstream work will be needed for
    /// that integration to be fully supported.
    #[prost(string, tag = "2")]
    pub resolver_url: ::prost::alloc::string::String,
    /// public is a boolean indicating whether the resolver is public or not.
    /// If public is false then only the definer can register data with this
    /// resolver.
    #[prost(bool, tag = "3")]
    pub public: bool,
}
/// MsgDefineResolverResponse is the Msg/DefineResolver response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgDefineResolverResponse {
    /// resolver_id is the integer ID of the resolver to be used in
    /// MsgRegisterResolver.
    #[prost(uint64, tag = "1")]
    pub resolver_id: u64,
}
/// MsgRegisterResolver is the Msg/RegisterResolver request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRegisterResolver {
    /// signer is the address registering data with the resolver. If
    /// the resolver is not public then the signer must be the definer
    /// of the resolver.
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    /// resolver_id is the ID of a resolver defined with Msg/DefineResolver.
    #[prost(uint64, tag = "2")]
    pub resolver_id: u64,
    /// content_hashes is a list of content hashes which the resolver claims to
    /// serve.
    #[prost(message, repeated, tag = "3")]
    pub content_hashes: ::prost::alloc::vec::Vec<ContentHash>,
}
/// MsgRegisterResolverResponse is the Msg/RegisterResolver response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRegisterResolverResponse {}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg is the regen.data.v1 Msg service
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Anchor "anchors" a piece of data to the blockchain based on its secure
        /// hash, effectively providing a tamper resistant timestamp.
        ///
        /// The sender in Anchor is not attesting to the veracity of the underlying
        /// data. They can simply be an intermediary providing timestamp services.
        /// Attest should be used to create a digital signature attesting to the
        /// veracity of some piece of data.
        pub async fn anchor(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAnchor>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAnchorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/regen.data.v2.Msg/Anchor");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("regen.data.v2.Msg", "Anchor"));
            self.inner.unary(req, path, codec).await
        }
        /// Attest allows for digital signing of an arbitrary piece of data on the
        /// blockchain. By attesting to data, the attestor is making a statement about
        /// the veracity of the data itself. It is like signing a legal document,
        /// meaning that I agree to all conditions and to the best of my knowledge
        /// everything is true. When anchoring data, the sender is not attesting to the
        /// veracity of the data, they are simply communicating that it exists.
        ///
        /// On-chain signatures have the following benefits:
        /// - on-chain identities can be managed using different cryptographic keys
        ///   that change over time through key rotation practices
        /// - an on-chain identity may represent an organization and through delegation
        ///   individual members may sign on behalf of the group
        /// - the blockchain transaction envelope provides built-in replay protection
        ///   and timestamping
        ///
        /// Attest implicitly calls Anchor if the data was not already anchored.
        ///
        /// Attest can be called multiple times for the same content hash with
        /// different attestors and those attestors will be appended to the list of
        /// attestors. If the same attestor attempts to attest to the same piece of
        /// data, the attestor will be ignored and a new attestation with a new
        /// timestamp will not be added.
        pub async fn attest(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAttest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAttestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/regen.data.v2.Msg/Attest");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("regen.data.v2.Msg", "Attest"));
            self.inner.unary(req, path, codec).await
        }
        /// DefineResolver defines a resolver URL and assigns it a new integer ID
        /// that can be used in calls to RegisterResolver.
        pub async fn define_resolver(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgDefineResolver>,
        ) -> std::result::Result<
            tonic::Response<super::MsgDefineResolverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Msg/DefineResolver",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Msg", "DefineResolver"));
            self.inner.unary(req, path, codec).await
        }
        /// RegisterResolver registers data content hashes
        pub async fn register_resolver(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRegisterResolver>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRegisterResolverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Msg/RegisterResolver",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Msg", "RegisterResolver"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// EventAnchor is an event emitted when data is anchored on chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventAnchor {
    /// iri is the IRI of the data anchored on chain.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// EventAttest is an event emitted when data is attested to on chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventAttest {
    /// iri is the IRI of the data attested to.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// attestor is the address of the account that has attested to the veracity of
    /// the data.
    #[prost(string, tag = "2")]
    pub attestor: ::prost::alloc::string::String,
}
/// EventDefineResolver is an event emitted when a resolved is defined on chain.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventDefineResolver {
    /// id is the ID of the defined resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
/// EventRegisterResolver is an event emitted when data is registered to a
/// resolver on chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRegisterResolver {
    /// id is the ID of the resolver that the data was registered to.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// iri is the IRI of the data that was registered.
    #[prost(string, tag = "2")]
    pub iri: ::prost::alloc::string::String,
}
/// QueryAnchorByIRIRequest is the Query/AnchorByIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByIriRequest {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// QueryAnchorByIRIResponse is the Query/AnchorByIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByIriResponse {
    /// anchor is information about the data anchor.
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<AnchorInfo>,
}
/// QueryAnchorByHashRequest is the Query/AnchorByHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByHashRequest {
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// QueryAnchorByHashResponse is the Query/AnchorByHash response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByHashResponse {
    /// anchor is information about the data anchor.
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<AnchorInfo>,
}
/// QueryAttestationsByAttestorRequest is the Query/AttestationsByAttestor
/// request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByAttestorRequest {
    /// attestor is the address of the attestor.
    #[prost(string, tag = "1")]
    pub attestor: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAttestationsByAttestorResponse is the Query/AttestationsByAttestor
/// response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByAttestorResponse {
    /// attestations are the attestations by the attestor.
    #[prost(message, repeated, tag = "1")]
    pub attestations: ::prost::alloc::vec::Vec<AttestationInfo>,
    /// pagination is the pagination PageResponse.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryAttestationsByIRIRequest is the Query/AttestationsByIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByIriRequest {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAttestationsByIRIResponse is the Query/AttestationsByIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByIriResponse {
    /// attestations are the attestations that have been made to the anchored data.
    #[prost(message, repeated, tag = "1")]
    pub attestations: ::prost::alloc::vec::Vec<AttestationInfo>,
    /// pagination is the pagination PageResponse.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryAttestationsByHashRequest is the Query/AttestationsByHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByHashRequest {
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAttestationsByHashResponse is the Query/AttestationsByHash response
/// type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByHashResponse {
    /// attestations are the attestations that have been made to the anchored data.
    #[prost(message, repeated, tag = "1")]
    pub attestations: ::prost::alloc::vec::Vec<AttestationInfo>,
    /// pagination is the pagination PageResponse.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryResolverRequest is the Query/Resolver request type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryResolverRequest {
    /// id is the ID of the resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
/// QueryResolverResponse is the Query/Resolver response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolverResponse {
    /// resolver is information about the resolver.
    #[prost(message, optional, tag = "1")]
    pub resolver: ::core::option::Option<ResolverInfo>,
}
/// QueryResolversByIRIRequest is the Query/ResolversByIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByIriRequest {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryResolversByIRIResponse is the Query/ResolversByIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByIriResponse {
    /// resolvers are the resolvers that have registered the anchored data.
    #[prost(message, repeated, tag = "1")]
    pub resolvers: ::prost::alloc::vec::Vec<ResolverInfo>,
    /// pagination is the PageResponse to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryResolversByHashRequest is the Query/ResolversByHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByHashRequest {
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryResolversByHashResponse is the Query/ResolversByHash response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByHashResponse {
    /// resolvers are the resolvers that have registered the data.
    #[prost(message, repeated, tag = "1")]
    pub resolvers: ::prost::alloc::vec::Vec<ResolverInfo>,
    /// pagination is the PageResponse to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryResolversByURLRequest is the Query/ResolversByURL request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByUrlRequest {
    /// url is the URL of the resolver.
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryResolversByURLResponse is the Query/ResolversByURL response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByUrlResponse {
    /// resolvers are the resolvers that have a matching URL.
    #[prost(message, repeated, tag = "1")]
    pub resolvers: ::prost::alloc::vec::Vec<ResolverInfo>,
    /// pagination is the PageResponse to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// ConvertIRIToHashRequest is the Query/ConvertIRIToHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertIriToHashRequest {
    /// iri is the IRI to convert to a ContentHash.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// ConvertIRIToHashResponse is the Query/ConvertIRIToHash response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertIriToHashResponse {
    /// content_hash is the ContentHash converted from the IRI.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// ConvertHashToIRIRequest is the Query/ConvertHashToIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertHashToIriRequest {
    /// content_hash is the ContentHash to convert to an IRI.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// ConvertHashToIRIResponse is the Query/ConvertHashToIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertHashToIriResponse {
    /// iri is the IRI converted from the ContentHash.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// AnchorInfo is the information for a data anchor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnchorInfo {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "2")]
    pub content_hash: ::core::option::Option<ContentHash>,
    /// timestamp is the time at which the data was anchored.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// AttestationInfo is the information for an attestation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationInfo {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// attestor is the address of the account that attested to the anchored data.
    #[prost(string, tag = "2")]
    pub attestor: ::prost::alloc::string::String,
    /// timestamp is the time at which the data was attested to.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// ResolverInfo is the information for a resolver.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolverInfo {
    /// id is the ID of the resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// url is the URL of the resolver.
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// manager is the address of the account that manages the resolver.
    /// This will be empty if the resolver is public.
    #[prost(string, tag = "3")]
    pub manager: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query is the regen.data.v1 Query service
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// AnchorByIRI queries a data anchor by the IRI of the data.
        pub async fn anchor_by_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAnchorByIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAnchorByIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/AnchorByIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "AnchorByIRI"));
            self.inner.unary(req, path, codec).await
        }
        /// AnchorByHash queries a data anchor by the ContentHash of the data.
        pub async fn anchor_by_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAnchorByHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAnchorByHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/AnchorByHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "AnchorByHash"));
            self.inner.unary(req, path, codec).await
        }
        /// AttestationsByAttestor queries data attestations by an attestor.
        pub async fn attestations_by_attestor(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAttestationsByAttestorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAttestationsByAttestorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/AttestationsByAttestor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.data.v2.Query", "AttestationsByAttestor"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// AttestationsByIRI queries data attestations by the IRI of the data.
        pub async fn attestations_by_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAttestationsByIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAttestationsByIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/AttestationsByIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "AttestationsByIRI"));
            self.inner.unary(req, path, codec).await
        }
        /// AttestationsByHash queries data attestations by the ContentHash of the
        /// data.
        pub async fn attestations_by_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAttestationsByHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAttestationsByHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/AttestationsByHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "AttestationsByHash"));
            self.inner.unary(req, path, codec).await
        }
        /// Resolver queries a resolver by its unique identifier.
        pub async fn resolver(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolverRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/Resolver",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "Resolver"));
            self.inner.unary(req, path, codec).await
        }
        /// ResolversByIRI queries resolvers with registered data by the IRI of the
        /// data.
        pub async fn resolvers_by_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolversByIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolversByIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/ResolversByIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "ResolversByIRI"));
            self.inner.unary(req, path, codec).await
        }
        /// ResolversByHash queries resolvers with registered data by the ContentHash
        /// of the data.
        pub async fn resolvers_by_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolversByHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolversByHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/ResolversByHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "ResolversByHash"));
            self.inner.unary(req, path, codec).await
        }
        /// ResolversByURL queries resolvers by URL.
        pub async fn resolvers_by_url(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolversByUrlRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolversByUrlResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/ResolversByURL",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "ResolversByURL"));
            self.inner.unary(req, path, codec).await
        }
        /// ConvertIRIToHash converts an IRI to a ContentHash.
        pub async fn convert_iri_to_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::ConvertIriToHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertIriToHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/ConvertIRIToHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "ConvertIRIToHash"));
            self.inner.unary(req, path, codec).await
        }
        /// ConvertHashToIRI converts a ContentHash to an IRI.
        pub async fn convert_hash_to_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::ConvertHashToIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertHashToIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v2.Query/ConvertHashToIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v2.Query", "ConvertHashToIRI"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// DataID stores a compact data ID and its full IRI.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataId {
    /// id is the compact automatically-generated data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// iri is the IRI of the data which contains its full ContentHash.
    #[prost(string, tag = "2")]
    pub iri: ::prost::alloc::string::String,
}
/// DataAnchor stores the anchor timestamp for a data object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAnchor {
    /// id is the compact data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// timestamp is the anchor timestamp for this object - the time at which
    /// it was first known to the blockchain.
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// DataAttestor is a join table for associating data IDs and attestors.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttestor {
    /// id is the compact data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// attestor is the account address of the attestor.
    #[prost(bytes = "vec", tag = "2")]
    pub attestor: ::prost::alloc::vec::Vec<u8>,
    /// timestamp is the time at which the attestor signed this data object.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// Resolver describes a data resolver.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resolver {
    /// id is the ID of the resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// url is the URL of the resolver.
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// manager is the bytes address of the resolver manager who defined
    /// this resolver. If the resolver is public, then this field is empty.
    #[prost(bytes = "vec", tag = "3")]
    pub manager: ::prost::alloc::vec::Vec<u8>,
}
/// DataResolver is a join table between data objects and resolvers and indicates
/// that a resolver claims to be able to resolve this data object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataResolver {
    /// id is the compact data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// resolver_id is the ID of the resolver.
    #[prost(uint64, tag = "2")]
    pub resolver_id: u64,
}
