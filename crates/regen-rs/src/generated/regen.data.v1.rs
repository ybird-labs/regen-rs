// This file is @generated by prost-build.
/// ContentHash specifies a hash-based content identifier for a piece of data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentHash {
    /// Raw specifies "raw" data which does not specify a deterministic, canonical
    /// encoding. Users of these hashes MUST maintain a copy of the hashed data
    /// which is preserved bit by bit. All other content encodings specify a
    /// deterministic, canonical encoding allowing implementations to choose from a
    /// variety of alternative formats for transport and encoding while maintaining
    /// the guarantee that the canonical hash will not change. The media type for
    /// "raw" data is defined by the MediaType enum.
    #[prost(message, optional, tag = "1")]
    pub raw: ::core::option::Option<content_hash::Raw>,
    /// Graph specifies graph data that conforms to the RDF data model.
    /// The canonicalization algorithm used for an RDF graph is specified by
    /// GraphCanonicalizationAlgorithm.
    #[prost(message, optional, tag = "2")]
    pub graph: ::core::option::Option<content_hash::Graph>,
}
/// Nested message and enum types in `ContentHash`.
pub mod content_hash {
    /// Raw is the content hash type used for raw data.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Raw {
        /// hash represents the hash of the data based on the specified
        /// digest_algorithm.
        #[prost(bytes = "vec", tag = "1")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
        /// digest_algorithm represents the hash digest algorithm.
        #[prost(enumeration = "super::DigestAlgorithm", tag = "2")]
        pub digest_algorithm: i32,
        /// media_type represents the media type for raw data.
        #[prost(enumeration = "super::RawMediaType", tag = "3")]
        pub media_type: i32,
    }
    /// Graph is the content hash type used for RDF graph data.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Graph {
        /// hash represents the hash of the data based on the specified
        /// digest_algorithm.
        #[prost(bytes = "vec", tag = "1")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
        /// digest_algorithm represents the hash digest algorithm.
        #[prost(enumeration = "super::DigestAlgorithm", tag = "2")]
        pub digest_algorithm: i32,
        /// graph_canonicalization_algorithm represents the RDF graph
        /// canonicalization algorithm.
        #[prost(enumeration = "super::GraphCanonicalizationAlgorithm", tag = "3")]
        pub canonicalization_algorithm: i32,
        /// merkle_tree is the merkle tree type used for the graph hash, if any.
        #[prost(enumeration = "super::GraphMerkleTree", tag = "4")]
        pub merkle_tree: i32,
    }
}
/// ContentHashes contains list of content ContentHash.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContentHashes {
    /// data is a list of content hashes which the resolver claims to serve.
    #[prost(message, repeated, tag = "1")]
    pub content_hashes: ::prost::alloc::vec::Vec<ContentHash>,
}
/// DigestAlgorithm is the hash digest algorithm
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DigestAlgorithm {
    /// unspecified and invalid
    Unspecified = 0,
    /// BLAKE2b-256
    Blake2b256 = 1,
}
impl DigestAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DIGEST_ALGORITHM_UNSPECIFIED",
            Self::Blake2b256 => "DIGEST_ALGORITHM_BLAKE2B_256",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIGEST_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "DIGEST_ALGORITHM_BLAKE2B_256" => Some(Self::Blake2b256),
            _ => None,
        }
    }
}
/// RawMediaType defines MIME media types to be used with a ContentHash.Raw hash.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RawMediaType {
    /// RAW_MEDIA_TYPE_UNSPECIFIED can be used for raw binary data
    Unspecified = 0,
    /// plain text
    TextPlain = 1,
    /// JSON
    Json = 2,
    /// CSV
    Csv = 3,
    /// XML
    Xml = 4,
    /// PDF
    Pdf = 5,
    /// TIIF
    Tiff = 16,
    /// JPG
    Jpg = 17,
    /// PNG
    Png = 18,
    /// SVG
    Svg = 19,
    /// WEBP
    Webp = 20,
    /// AVIF
    Avif = 21,
    /// GIF
    Gif = 22,
    /// APNG
    Apng = 23,
    /// MPEG
    Mpeg = 32,
    /// MP4
    Mp4 = 33,
    /// WEBM
    Webm = 34,
    /// OGG
    Ogg = 35,
}
impl RawMediaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RAW_MEDIA_TYPE_UNSPECIFIED",
            Self::TextPlain => "RAW_MEDIA_TYPE_TEXT_PLAIN",
            Self::Json => "RAW_MEDIA_TYPE_JSON",
            Self::Csv => "RAW_MEDIA_TYPE_CSV",
            Self::Xml => "RAW_MEDIA_TYPE_XML",
            Self::Pdf => "RAW_MEDIA_TYPE_PDF",
            Self::Tiff => "RAW_MEDIA_TYPE_TIFF",
            Self::Jpg => "RAW_MEDIA_TYPE_JPG",
            Self::Png => "RAW_MEDIA_TYPE_PNG",
            Self::Svg => "RAW_MEDIA_TYPE_SVG",
            Self::Webp => "RAW_MEDIA_TYPE_WEBP",
            Self::Avif => "RAW_MEDIA_TYPE_AVIF",
            Self::Gif => "RAW_MEDIA_TYPE_GIF",
            Self::Apng => "RAW_MEDIA_TYPE_APNG",
            Self::Mpeg => "RAW_MEDIA_TYPE_MPEG",
            Self::Mp4 => "RAW_MEDIA_TYPE_MP4",
            Self::Webm => "RAW_MEDIA_TYPE_WEBM",
            Self::Ogg => "RAW_MEDIA_TYPE_OGG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RAW_MEDIA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RAW_MEDIA_TYPE_TEXT_PLAIN" => Some(Self::TextPlain),
            "RAW_MEDIA_TYPE_JSON" => Some(Self::Json),
            "RAW_MEDIA_TYPE_CSV" => Some(Self::Csv),
            "RAW_MEDIA_TYPE_XML" => Some(Self::Xml),
            "RAW_MEDIA_TYPE_PDF" => Some(Self::Pdf),
            "RAW_MEDIA_TYPE_TIFF" => Some(Self::Tiff),
            "RAW_MEDIA_TYPE_JPG" => Some(Self::Jpg),
            "RAW_MEDIA_TYPE_PNG" => Some(Self::Png),
            "RAW_MEDIA_TYPE_SVG" => Some(Self::Svg),
            "RAW_MEDIA_TYPE_WEBP" => Some(Self::Webp),
            "RAW_MEDIA_TYPE_AVIF" => Some(Self::Avif),
            "RAW_MEDIA_TYPE_GIF" => Some(Self::Gif),
            "RAW_MEDIA_TYPE_APNG" => Some(Self::Apng),
            "RAW_MEDIA_TYPE_MPEG" => Some(Self::Mpeg),
            "RAW_MEDIA_TYPE_MP4" => Some(Self::Mp4),
            "RAW_MEDIA_TYPE_WEBM" => Some(Self::Webm),
            "RAW_MEDIA_TYPE_OGG" => Some(Self::Ogg),
            _ => None,
        }
    }
}
/// GraphCanonicalizationAlgorithm is the graph canonicalization algorithm
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GraphCanonicalizationAlgorithm {
    /// unspecified and invalid
    Unspecified = 0,
    /// URDNA2015 graph hashing
    Urdna2015 = 1,
}
impl GraphCanonicalizationAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED",
            Self::Urdna2015 => "GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GRAPH_CANONICALIZATION_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "GRAPH_CANONICALIZATION_ALGORITHM_URDNA2015" => Some(Self::Urdna2015),
            _ => None,
        }
    }
}
/// GraphMerkleTree is the graph merkle tree type used for hashing, if any
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GraphMerkleTree {
    /// unspecified and valid
    NoneUnspecified = 0,
}
impl GraphMerkleTree {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoneUnspecified => "GRAPH_MERKLE_TREE_NONE_UNSPECIFIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GRAPH_MERKLE_TREE_NONE_UNSPECIFIED" => Some(Self::NoneUnspecified),
            _ => None,
        }
    }
}
/// MsgAnchor is the Msg/Anchor request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAnchor {
    /// sender is the address of the sender of the transaction. The sender in
    /// Anchor is not attesting to the veracity of the underlying data. They
    /// can simply be an intermediary providing services.
    #[prost(string, tag = "1")]
    pub sender: ::prost::alloc::string::String,
    /// content_hash is the content hash for the data to anchor.
    #[prost(message, optional, tag = "2")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// MsgAnchor is the Msg/Anchor response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAnchorResponse {
    /// iri is the IRI of the data that was anchored.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// timestamp is the time at which the data was anchored.
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// MsgAttest is the Msg/Attest request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAttest {
    /// attestor is the addresses of the account attesting to the veracity of the
    /// data. By making an Attest request, the attestor is attesting to the
    /// veracity of the data referenced by the IRI. The precise meaning of this may
    /// vary depending on the underlying data.
    #[prost(string, tag = "1")]
    pub attestor: ::prost::alloc::string::String,
    /// content_hashes are the content hashes for anchored data. Only RDF graph
    /// data can be signed as its data model is intended to specifically convey
    /// semantic meaning.
    #[prost(message, repeated, tag = "2")]
    pub content_hashes: ::prost::alloc::vec::Vec<content_hash::Graph>,
}
/// MsgAttestResponse is the Msg/Attest response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAttestResponse {
    /// iris are the IRIs of the data that was attested to. If the attestor attests
    /// to the same piece of data, the previous attestation will not be updated and
    /// the IRI will not be included in this list.
    #[prost(string, repeated, tag = "1")]
    pub iris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// timestamp is the time at which any new attestations were made.
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// MsgDefineResolver is the Msg/DefineResolver request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDefineResolver {
    /// manager is the address of the resolver manager. The manager is able
    /// to make future calls using the ID returned by this operation with
    /// Msg/RegisterResolver. To authorize other accounts to register resolvers,
    /// the manager should make use of cosmos.authz.
    #[prost(string, tag = "1")]
    pub manager: ::prost::alloc::string::String,
    /// resolver_url is a resolver URL which should refer to an HTTP service
    /// which will respond to a GET request with the IRI of a ContentHash
    /// and return the content if it exists or a 404. For graph data, resolvers
    /// should use the HTTP Accept header to negotiate the RDF serialization
    /// format.
    #[prost(string, tag = "2")]
    pub resolver_url: ::prost::alloc::string::String,
}
/// MsgDefineResolverResponse is the Msg/DefineResolver response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgDefineResolverResponse {
    /// resolver_id is the integer ID of the resolver to be used in
    /// MsgRegisterResolver.
    #[prost(uint64, tag = "1")]
    pub resolver_id: u64,
}
/// MsgRegisterResolver is the Msg/RegisterResolver request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRegisterResolver {
    /// manager is the address of the resolver manager who registered this
    /// resolver with Msg/DefinedResolver.
    #[prost(string, tag = "1")]
    pub manager: ::prost::alloc::string::String,
    /// resolver_id is the ID of a resolver defined with Msg/DefineResolver.
    #[prost(uint64, tag = "2")]
    pub resolver_id: u64,
    /// content_hashes is a list of content hashes which the resolver claims to
    /// serve.
    #[prost(message, repeated, tag = "3")]
    pub content_hashes: ::prost::alloc::vec::Vec<ContentHash>,
}
/// MsgRegisterResolverResponse is the Msg/RegisterResolver response type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRegisterResolverResponse {}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg is the regen.data.v1 Msg service
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Anchor "anchors" a piece of data to the blockchain based on its secure
        /// hash, effectively providing a tamper resistant timestamp.
        ///
        /// The sender in Anchor is not attesting to the veracity of the underlying
        /// data. They can simply be an intermediary providing timestamp services.
        /// Attest should be used to create a digital signature attesting to the
        /// veracity of some piece of data.
        pub async fn anchor(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAnchor>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAnchorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/regen.data.v1.Msg/Anchor");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("regen.data.v1.Msg", "Anchor"));
            self.inner.unary(req, path, codec).await
        }
        /// Attest allows for digital signing of an arbitrary piece of data on the
        /// blockchain. By attesting to data, the attestor is making a statement about
        /// the veracity of the data itself. It is like signing a legal document,
        /// meaning that I agree to all conditions and to the best of my knowledge
        /// everything is true. When anchoring data, the sender is not attesting to the
        /// veracity of the data, they are simply communicating that it exists.
        ///
        /// On-chain signatures have the following benefits:
        /// - on-chain identities can be managed using different cryptographic keys
        ///   that change over time through key rotation practices
        /// - an on-chain identity may represent an organization and through delegation
        ///   individual members may sign on behalf of the group
        /// - the blockchain transaction envelope provides built-in replay protection
        ///   and timestamping
        ///
        /// Attest implicitly calls Anchor if the data was not already anchored.
        ///
        /// Attest can be called multiple times for the same content hash with
        /// different attestors and those attestors will be appended to the list of
        /// attestors. If the same attestor attempts to attest to the same piece of
        /// data, the attestor will be ignored and a new attestation with a new
        /// timestamp will not be added.
        pub async fn attest(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgAttest>,
        ) -> std::result::Result<
            tonic::Response<super::MsgAttestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/regen.data.v1.Msg/Attest");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("regen.data.v1.Msg", "Attest"));
            self.inner.unary(req, path, codec).await
        }
        /// DefineResolver defines a resolver URL and assigns it a new integer ID
        /// that can be used in calls to RegisterResolver.
        pub async fn define_resolver(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgDefineResolver>,
        ) -> std::result::Result<
            tonic::Response<super::MsgDefineResolverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Msg/DefineResolver",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Msg", "DefineResolver"));
            self.inner.unary(req, path, codec).await
        }
        /// RegisterResolver registers data content hashes
        pub async fn register_resolver(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRegisterResolver>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRegisterResolverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Msg/RegisterResolver",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Msg", "RegisterResolver"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// EventAnchor is an event emitted when data is anchored on chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventAnchor {
    /// iri is the IRI of the data anchored on chain.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// EventAttest is an event emitted when data is attested to on chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventAttest {
    /// iri is the IRI of the data attested to.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// attestor is the address of the account that has attested to the veracity of
    /// the data.
    #[prost(string, tag = "2")]
    pub attestor: ::prost::alloc::string::String,
}
/// EventDefineResolver is an event emitted when a resolved is defined on chain.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EventDefineResolver {
    /// id is the ID of the defined resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
/// EventRegisterResolver is an event emitted when data is registered to a
/// resolver on chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRegisterResolver {
    /// id is the ID of the resolver that the data was registered to.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// iri is the IRI of the data that was registered.
    #[prost(string, tag = "2")]
    pub iri: ::prost::alloc::string::String,
}
/// QueryAnchorByIRIRequest is the Query/AnchorByIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByIriRequest {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// QueryAnchorByIRIResponse is the Query/AnchorByIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByIriResponse {
    /// anchor is information about the data anchor.
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<AnchorInfo>,
}
/// QueryAnchorByHashRequest is the Query/AnchorByHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByHashRequest {
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// QueryAnchorByHashResponse is the Query/AnchorByHash response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAnchorByHashResponse {
    /// anchor is information about the data anchor.
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<AnchorInfo>,
}
/// QueryAttestationsByAttestorRequest is the Query/AttestationsByAttestor
/// request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByAttestorRequest {
    /// attestor is the address of the attestor.
    #[prost(string, tag = "1")]
    pub attestor: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAttestationsByAttestorResponse is the Query/AttestationsByAttestor
/// response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByAttestorResponse {
    /// attestations are the attestations by the attestor.
    #[prost(message, repeated, tag = "1")]
    pub attestations: ::prost::alloc::vec::Vec<AttestationInfo>,
    /// pagination is the pagination PageResponse.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryAttestationsByIRIRequest is the Query/AttestationsByIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByIriRequest {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAttestationsByIRIResponse is the Query/AttestationsByIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByIriResponse {
    /// attestations are the attestations that have been made to the anchored data.
    #[prost(message, repeated, tag = "1")]
    pub attestations: ::prost::alloc::vec::Vec<AttestationInfo>,
    /// pagination is the pagination PageResponse.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryAttestationsByHashRequest is the Query/AttestationsByHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByHashRequest {
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryAttestationsByHashResponse is the Query/AttestationsByHash response
/// type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAttestationsByHashResponse {
    /// attestations are the attestations that have been made to the anchored data.
    #[prost(message, repeated, tag = "1")]
    pub attestations: ::prost::alloc::vec::Vec<AttestationInfo>,
    /// pagination is the pagination PageResponse.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryResolverRequest is the Query/Resolver request type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryResolverRequest {
    /// id is the ID of the resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
/// QueryResolverResponse is the Query/Resolver response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolverResponse {
    /// resolver is information about the resolver.
    #[prost(message, optional, tag = "1")]
    pub resolver: ::core::option::Option<ResolverInfo>,
}
/// QueryResolversByIRIRequest is the Query/ResolversByIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByIriRequest {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryResolversByIRIResponse is the Query/ResolversByIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByIriResponse {
    /// resolvers are the resolvers that have registered the anchored data.
    #[prost(message, repeated, tag = "1")]
    pub resolvers: ::prost::alloc::vec::Vec<ResolverInfo>,
    /// pagination is the PageResponse to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryResolversByHashRequest is the Query/ResolversByHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByHashRequest {
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryResolversByHashResponse is the Query/ResolversByHash response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByHashResponse {
    /// resolvers are the resolvers that have registered the data.
    #[prost(message, repeated, tag = "1")]
    pub resolvers: ::prost::alloc::vec::Vec<ResolverInfo>,
    /// pagination is the PageResponse to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// QueryResolversByURLRequest is the Query/ResolversByURL request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByUrlRequest {
    /// url is the URL of the resolver.
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// pagination is the PageRequest to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
/// QueryResolversByURLResponse is the Query/ResolversByURL response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResolversByUrlResponse {
    /// resolvers are the resolvers that have a matching URL.
    #[prost(message, repeated, tag = "1")]
    pub resolvers: ::prost::alloc::vec::Vec<ResolverInfo>,
    /// pagination is the PageResponse to use for pagination.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        ::cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
/// ConvertIRIToHashRequest is the Query/ConvertIRIToHash request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertIriToHashRequest {
    /// iri is the IRI to convert to a ContentHash.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// ConvertIRIToHashResponse is the Query/ConvertIRIToHash response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertIriToHashResponse {
    /// content_hash is the ContentHash converted from the IRI.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// ConvertHashToIRIRequest is the Query/ConvertHashToIRI request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertHashToIriRequest {
    /// content_hash is the ContentHash to convert to an IRI.
    #[prost(message, optional, tag = "1")]
    pub content_hash: ::core::option::Option<ContentHash>,
}
/// ConvertHashToIRIResponse is the Query/ConvertHashToIRI response type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConvertHashToIriResponse {
    /// iri is the IRI converted from the ContentHash.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
}
/// AnchorInfo is the information for a data anchor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnchorInfo {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// content_hash is the ContentHash of the anchored data.
    #[prost(message, optional, tag = "2")]
    pub content_hash: ::core::option::Option<ContentHash>,
    /// timestamp is the time at which the data was anchored.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// AttestationInfo is the information for an attestation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttestationInfo {
    /// iri is the IRI of the anchored data.
    #[prost(string, tag = "1")]
    pub iri: ::prost::alloc::string::String,
    /// attestor is the address of the account that attested to the anchored data.
    #[prost(string, tag = "2")]
    pub attestor: ::prost::alloc::string::String,
    /// timestamp is the time at which the data was attested to.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// ResolverInfo is the information for a resolver.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolverInfo {
    /// id is the ID of the resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// url is the URL of the resolver.
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// manager is the address of the account that manages the resolver.
    #[prost(string, tag = "3")]
    pub manager: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query is the regen.data.v1 Query service
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// AnchorByIRI queries a data anchor by the IRI of the data.
        pub async fn anchor_by_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAnchorByIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAnchorByIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/AnchorByIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "AnchorByIRI"));
            self.inner.unary(req, path, codec).await
        }
        /// AnchorByHash queries a data anchor by the ContentHash of the data.
        pub async fn anchor_by_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAnchorByHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAnchorByHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/AnchorByHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "AnchorByHash"));
            self.inner.unary(req, path, codec).await
        }
        /// AttestationsByAttestor queries data attestations by an attestor.
        pub async fn attestations_by_attestor(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAttestationsByAttestorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAttestationsByAttestorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/AttestationsByAttestor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("regen.data.v1.Query", "AttestationsByAttestor"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// AttestationsByIRI queries data attestations by the IRI of the data.
        pub async fn attestations_by_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAttestationsByIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAttestationsByIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/AttestationsByIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "AttestationsByIRI"));
            self.inner.unary(req, path, codec).await
        }
        /// AttestationsByHash queries data attestations by the ContentHash of the
        /// data.
        pub async fn attestations_by_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAttestationsByHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAttestationsByHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/AttestationsByHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "AttestationsByHash"));
            self.inner.unary(req, path, codec).await
        }
        /// Resolver queries a resolver by its unique identifier.
        pub async fn resolver(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolverRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolverResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/Resolver",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "Resolver"));
            self.inner.unary(req, path, codec).await
        }
        /// ResolversByIRI queries resolvers with registered data by the IRI of the
        /// data.
        pub async fn resolvers_by_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolversByIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolversByIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/ResolversByIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "ResolversByIRI"));
            self.inner.unary(req, path, codec).await
        }
        /// ResolversByHash queries resolvers with registered data by the ContentHash
        /// of the data.
        pub async fn resolvers_by_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolversByHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolversByHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/ResolversByHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "ResolversByHash"));
            self.inner.unary(req, path, codec).await
        }
        /// ResolversByURL queries resolvers by URL.
        pub async fn resolvers_by_url(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryResolversByUrlRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryResolversByUrlResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/ResolversByURL",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "ResolversByURL"));
            self.inner.unary(req, path, codec).await
        }
        /// ConvertIRIToHash converts an IRI to a ContentHash.
        pub async fn convert_iri_to_hash(
            &mut self,
            request: impl tonic::IntoRequest<super::ConvertIriToHashRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertIriToHashResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/ConvertIRIToHash",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "ConvertIRIToHash"));
            self.inner.unary(req, path, codec).await
        }
        /// ConvertHashToIRI converts a ContentHash to an IRI.
        pub async fn convert_hash_to_iri(
            &mut self,
            request: impl tonic::IntoRequest<super::ConvertHashToIriRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConvertHashToIriResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/regen.data.v1.Query/ConvertHashToIRI",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("regen.data.v1.Query", "ConvertHashToIRI"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// DataID stores a compact data ID and its full IRI.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataId {
    /// id is the compact automatically-generated data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// iri is the IRI of the data which contains its full ContentHash.
    #[prost(string, tag = "2")]
    pub iri: ::prost::alloc::string::String,
}
/// DataAnchor stores the anchor timestamp for a data object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAnchor {
    /// id is the compact data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// timestamp is the anchor timestamp for this object - the time at which
    /// it was first known to the blockchain.
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// DataAttestor is a join table for associating data IDs and attestors.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAttestor {
    /// id is the compact data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// attestor is the account address of the attestor.
    #[prost(bytes = "vec", tag = "2")]
    pub attestor: ::prost::alloc::vec::Vec<u8>,
    /// timestamp is the time at which the attestor signed this data object.
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
}
/// Resolver describes a data resolver.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resolver {
    /// id is the ID of the resolver.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// url is the URL of the resolver.
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// manager is the bytes address of the resolver manager who is allowed
    /// to make calls to Msg/RegisterResolver for this resolver.
    #[prost(bytes = "vec", tag = "3")]
    pub manager: ::prost::alloc::vec::Vec<u8>,
}
/// DataResolver is a join table between data objects and resolvers and indicates
/// that a resolver claims to be able to resolve this data object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataResolver {
    /// id is the compact data ID.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// resolver_id is the ID of the resolver.
    #[prost(uint64, tag = "2")]
    pub resolver_id: u64,
}
